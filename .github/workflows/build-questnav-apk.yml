name: Build QuestNav App
on:
  workflow_call:
    inputs:
      versionYear:
        description: 'Current FRC year'
        required: false
        type: string
      versionMajor:
        description: 'Major version'
        required: false
        type: string
      versionMinor:
        description: 'Minor version'
        required: false
        type: string
      versionPatch:
        description: 'Patch version'
        required: false
        type: string
      versionType:
        description: 'Type of version'
        required: false
        type: string
      devBuild:
        type: boolean
        default: true
        description: "Build a development variant"
    secrets:
      UNITY_LICENSE:
        description: 'Unity license'
        required: false
      UNITY_EMAIL:
        description: 'Unity email'
        required: false
      UNITY_PASSWORD:
        description: 'Unity password'
        required: false
    outputs:
        version:
          description: "Computed version string"
          value: ${{ jobs.build-unity.outputs.version }}
        version-code:
          description: "Computed Android versionCode"
          value: ${{ jobs.build-unity.outputs.version-code }}
        strategy:
          description: "Version strategy used (semantic|hash)"
          value: ${{ jobs.build-unity.outputs.strategy }}
        apk_path:
          description: "Built APK path (in the runner workspace)"
          value: ${{ jobs.build-unity.outputs.apk_path }}

jobs:
  build-unity:
    runs-on: [self-hosted, Windows]
    outputs:
      version: ${{ steps.set-version.outputs.version }}
      version-code: ${{ steps.set-version.outputs['version-code'] }}
      strategy: ${{ steps.set-version.outputs.strategy }}
      apk_path: ${{ steps.unity-build.outputs.apk_path }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Determine version strategy
        id: set-version
        shell: pwsh
        run: |
          # Read inputs as strings (may be empty in workflow_call)
          $year  = "${{ inputs.versionYear }}"
          $major = "${{ inputs.versionMajor }}"
          $minor = "${{ inputs.versionMinor }}"
          $patch = "${{ inputs.versionPatch }}"
          $vtype = "${{ inputs.versionType }}"
          $isDevInput = "${{ inputs.devBuild }}"
      
          $haveSem = -not [string]::IsNullOrWhiteSpace($year) `
                     -and -not [string]::IsNullOrWhiteSpace($major) `
                     -and -not [string]::IsNullOrWhiteSpace($minor) `
                     -and -not [string]::IsNullOrWhiteSpace($patch)
      
          if ($haveSem) {
            # Semantic versioning: YEAR.MAJOR.MINOR.PATCH[-TYPE]
            $version = "$year.$major.$minor.$patch"
            if (-not [string]::IsNullOrWhiteSpace($vtype)) { $version = "$version-$vtype" }
      
            # Android versionCode = (YEAR-2020)*100000000 + MAJOR*1000000 + MINOR*1000 + PATCH
            $yearI  = [int]$year
            $majorI = [int]$major
            $minorI = [int]$minor
            $patchI = [int]$patch
            $code   = (($yearI - 2020) * 100000000) + ($majorI * 1000000) + ($minorI * 1000) + $patchI
            $strategy = 'semantic'
          } else {
            # Hash-based: <7-char-hash>-dev  and versionCode = 1_000_000 + commitCount
            $commitHash  = (git rev-parse --short=7 HEAD).Trim()
            $commitCount = [int](git rev-list --count HEAD)
            $version = "$commitHash-dev"
            $code    = 1000000 + $commitCount
            $strategy = 'hash'
          }
      
          # Optional development flag passthrough
          $isDev = ($isDevInput.ToString().ToLower() -eq 'true')
      
          # ---- Step outputs expected by new logic ----
          "strategy=$strategy"          | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          "version=$version"            | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          "version-code=$code"          | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
      
          # ---- Back-compat outputs for the rest of your workflow ----
          "QUESTNAV_VERSION=$version"       | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          "QUESTNAV_VERSION_CODE=$code"     | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          if ($isDev) {
            "QUESTNAV_DEVELOPMENT_BUILD=1"  | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          }
      
          # ---- Also export to env for subsequent steps ----
          "QUESTNAV_VERSION=$version"       | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          "QUESTNAV_VERSION_CODE=$code"     | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          if ($isDev) {
            "QUESTNAV_DEVELOPMENT_BUILD=1"  | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          }

      - name: Resolve Unity.exe
        id: unity-path
        shell: pwsh
        run: |
          function Get-UnityVersionFromWorkflow([string]$ymlPath) {
            if (-not (Test-Path $ymlPath)) { return $null }
            $content = Get-Content -Raw -Path $ymlPath
            $m = [regex]::Match($content, "unityVersion:\s*([0-9\.a-zA-Z\-]+)")
            if ($m.Success) { return $m.Groups[1].Value } else { return $null }
          }

          $unity = $env:UNITY_EDITOR_PATH
          if (-not $unity) {
            $wfVersion = Get-UnityVersionFromWorkflow ".github/workflows/build-questnav-apk.yml"
            if ($wfVersion) {
              $candidate = "C:\Program Files\Unity\Hub\Editor\$wfVersion\Editor\Unity.exe"
              if (Test-Path $candidate) { $unity = $candidate }
            }
          }
          if (-not $unity) { $unity = "C:\Program Files\Unity\Hub\Editor\6000.0.58f1\Editor\Unity.exe" }
          if (-not (Test-Path $unity)) { throw "Unity Editor not found at: $unity" }
          "UNITY_EDITOR_PATH=$unity" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

      - name: Clean Unity artifacts
        shell: pwsh
        run: |
          $proj = "unity"
          @('Library','Temp','obj','Logs','build') | ForEach-Object {
            $p = Join-Path $proj $_
            if (Test-Path $p) {
              try {
                Remove-Item -Recurse -Force -LiteralPath -ErrorAction Stop $p
                Write-Host "Removed: $p"
              } catch {
                # Either wrap the var...
                # Write-Warning "Failed to remove $($p): $($_.Exception.Message)"
                # ...or use -f formatting (recommended)
                Write-Warning ("Failed to remove {0}: {1}" -f $p, $_.Exception.Message)
              }
            }
          }

      - name: Restore NuGetForUnity
        shell: pwsh
        run: |
          $proj = "unity"
          $cfg = Get-ChildItem -Path $proj -Recurse -Filter NuGet.config -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($cfg) {
            Write-Host "NuGetForUnity config: $($cfg.FullName)"
            dotnet tool install --global NuGetForUnity.Cli | Out-Null
            $env:PATH = "$($env:USERPROFILE)\.dotnet\tools;$env:PATH"
            nugetforunity restore $proj
          } else {
            Write-Host "NuGetForUnity config not found; skipping restore."
          }

      - name: Verify Google.Protobuf presence
        shell: pwsh
        run: |
          $dlls = Get-ChildItem -Path unity -Recurse -Filter Google.Protobuf.dll -ErrorAction SilentlyContinue
          if (-not $dlls) { Write-Error "Google.Protobuf.dll NOT found after restore."; exit 1 }
          $dll = $dlls | Select-Object -First 1
          $ver = (Get-Item $dll.FullName).VersionInfo.FileVersion
          Write-Host "Found Google.Protobuf at $($dll.FullName) (FileVersion=$ver)"

      - name: Vendor Google.Protobuf.dll (3.31.0)
        if: failure()
        shell: pwsh
        run: |
          $nupkg = "$PWD\google.protobuf.nupkg"
          Invoke-WebRequest -Uri https://www.nuget.org/api/v2/package/Google.Protobuf/3.31.0 -OutFile $nupkg
          Add-Type -AssemblyName System.IO.Compression.FileSystem
          $dest = "$PWD\.nupkg_gp"
          if (Test-Path $dest) { Remove-Item $dest -Recurse -Force }
          [System.IO.Compression.ZipFile]::ExtractToDirectory($nupkg, $dest)
          $src = Join-Path $dest "lib\netstandard2.0\Google.Protobuf.dll"
          $plug = "unity\Assets\Plugins\Google.Protobuf"
          New-Item -ItemType Directory -Force -Path $plug | Out-Null
          Copy-Item $src $plug -Force

      - name: Ensure Google.Protobuf.dll is visible to Unity
        shell: pwsh
        run: |
          $proj = "unity"
          # Find every copy of Google.Protobuf.dll in the project
          $all = Get-ChildItem -Path $proj -Recurse -Filter Google.Protobuf.dll -ErrorAction SilentlyContinue
          if (-not $all) { Write-Error "Google.Protobuf.dll not found under $proj"; exit 1 }
      
          # Prefer a netstandard2.0 (or net6/net472 if needed) path
          $pick = $all | Where-Object { $_.FullName -match '\\lib\\netstandard2\.0\\' } | Select-Object -First 1
          if (-not $pick) { $pick = $all | Select-Object -First 1 }
      
          # Put a canonical copy where Unity will always see it
          $plugins = Join-Path $proj "unity/Assets/Plugins/Google.Protobuf"
          New-Item -ItemType Directory -Force -Path $plugins | Out-Null
          Copy-Item $pick.FullName (Join-Path $plugins "Google.Protobuf.dll") -Force
      
          Write-Host "Using Google.Protobuf from: $($pick.FullName)"
          Write-Host "Placed at: $plugins\Google.Protobuf.dll"
      
          # Optional: fail if there are multiple copies (can confuse Unity)
          $others = $all | Where-Object { $_.FullName -ne $pick.FullName }
          if ($others) {
            Write-Warning "Other copies exist (may cause ambiguity):"
            $others | ForEach-Object { Write-Host " - $($_.FullName)" }
          }

      - name: Verify Unity Android modules
        shell: pwsh
        run: |
          $editorDir = Split-Path $env:UNITY_EDITOR_PATH -Parent
          $android   = Join-Path $editorDir 'Data\PlaybackEngines\AndroidPlayer'
          if (-not (Test-Path $android)) { Write-Error "Missing Android module: $android"; exit 1 }
          $paths = @(
            'SDK','NDK','OpenJDK','Tools','Gradle'
          ) | ForEach-Object { Join-Path $android $_ }
          foreach ($p in $paths) {
            if (-not (Test-Path $p)) { Write-Warning "Android component missing: $p" }
          }

      - name: Build with Unity (stream logs)
        id: unity-build
        timeout-minutes: 90
        shell: pwsh
        env:
          OVR_DISABLE_PROJECT_SETUP: "1"
          UPM_LOG_LEVEL: debug
        run: |
          $proj    = "unity"
          $unity   = $env:UNITY_EDITOR_PATH
          $logPath = Join-Path $PWD "local-unity-build.log"
          if (Test-Path $logPath) { Remove-Item $logPath -Force }
      
          # We'll tee console output into a file for artifact upload
          $args = @(
            '-batchmode','-nographics','-quit',
            '-accept-apiupdate',               # avoid API Updater prompt
            '-enablePackageManagerTraces',     # extra package manager logs
            '-buildTarget','Android',          # make target explicit
            '-projectPath', $proj,
            '-executeMethod','CI.Build.PerformAndroid',
            '-logFile','-'                     # <-- stream to stdout
          )
      
          # Run Unity and tee output to our log file
          # (&) blocks until Unity exits; $LASTEXITCODE will have Unity's exit code
          & "$unity" @args 2>&1 | Tee-Object -FilePath $logPath
          $exit = $LASTEXITCODE
      
          Write-Host "---- Tail of Unity log (from file) ----"
          if (Test-Path $logPath) { Get-Content $logPath -Tail 200 } else { Write-Warning "Unity log file not found at $logPath" }
          if ($exit -ne 0) { throw "Unity build failed with exit code $exit. See $logPath" }
      
          # Short post-exit grace period for file flush
          $apk = Join-Path $proj "build/Android/QuestNav-local.apk"
          for ($i=0; $i -lt 30 -and -not (Test-Path $apk); $i++) { Start-Sleep -Seconds 1 }
      
          if (-not (Test-Path $apk)) { throw "Expected APK not found at $apk. See $logPath" }
          "APK_PATH=$apk" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
        
        
      - name: Compute artifact name
        id: artifact
        shell: pwsh
        run: |
          $name = "QuestNav-${{ steps.set-version.outputs.version }}-${{ steps.set-version.outputs['version-code'] }}"
          if ("${{ inputs.devBuild }}".ToLower() -eq "true") { $name = "$name-dev" }
          "ARTIFACT_NAME=$name" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: Upload APK
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.artifact.outputs.ARTIFACT_NAME }}
          path: ${{ steps.unity-build.outputs.APK_PATH }}
          if-no-files-found: error

      - name: Upload Unity build log
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: unity-build-log-${{ steps.set-version.outputs.version }}
          path: local-unity-build.log
          retention-days: 7

      - name: Upload diagnostics
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: unity-diagnostics-${{ steps.set-version.outputs.version || 'unknown' }}
          if-no-files-found: warn
          retention-days: 7
          path: |
            local-unity-build.log
            ${{ env.LOCALAPPDATA }}\Unity\Editor\Editor.log
            ${{ env.LOCALAPPDATA }}\Unity\cache\logs\*
            ${{ env.APPDATA }}\Unity\Packages\logs\*
            unity\Library\**\*.log
            unity\Logs\**\*
            ${{ env.LOCALAPPDATA }}\Temp\Unity\Editor\Crashes\**

      - name: Preserve XML Documentation
        shell: pwsh
        run: |
          Write-Host "Preserving XML documentation file for DocFX..."
          $xmlPath = "unity/Library/ScriptAssemblies/QuestNav.xml"
          if (Test-Path $xmlPath) {
            Write-Host "Found QuestNav.xml, copying to persistent location..."
            New-Item -ItemType Directory -Force -Path "unity/DocFX/preserved-xml" | Out-Null
            Copy-Item $xmlPath "unity/DocFX/preserved-xml/QuestNav.xml" -Force
            Write-Host "XML documentation preserved at unity/DocFX/preserved-xml/QuestNav.xml"
            Get-ChildItem "unity/DocFX/preserved-xml/" | Format-Table -AutoSize
          }
          else {
            Write-Warning "QuestNav.xml not found at $xmlPath"
            Write-Host "Available files in ScriptAssemblies:"
            Get-ChildItem "unity/Library/ScriptAssemblies/" -File | Where-Object { $_.Extension -in '.xml','.dll' } | Format-Table -AutoSize
          }

      - name: Upload XML Documentation Artifact
        uses: actions/upload-artifact@v4
        if: success()
        with:
          name: questnav-xml-docs-${{ steps.set-version.outputs.version }}
          path: unity/DocFX/preserved-xml/QuestNav.xml
          retention-days: 30

  # Call DocFX workflow after successful Unity build
  build-docfx:
    name: Generate C# API Documentation
    needs: build-unity
    if: success()
    uses: ./.github/workflows/build-docfx-api.yml
    with:
      unity-build-completed: true
    permissions:
      contents: write
      pull-requests: write

  # Call Javadoc workflow after successful Unity build
  build-javadoc:
    name: Generate Java API Documentation
    needs: build-unity
    if: success()
    uses: ./.github/workflows/build-javadoc-api.yml
    with:
      unity-build-completed: true
    permissions:
      contents: write
      pull-requests: write