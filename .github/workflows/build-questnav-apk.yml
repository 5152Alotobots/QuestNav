name: Build QuestNav App
on:
  workflow_call:
    inputs:
      unityVersion:
        description: 'Unity Editor version'
        required: false
        type: string
        default: '6000.2.6f2'
      versionYear:
        description: 'Current FRC year'
        required: false
        type: string
      versionMajor:
        description: 'Major version'
        required: false
        type: string
      versionMinor:
        description: 'Minor version'
        required: false
        type: string
      versionPatch:
        description: 'Patch version'
        required: false
        type: string
      versionType:
        description: 'Type of version'
        required: false
        type: string
      devBuild:
        type: boolean
        default: true
        description: "Build a development variant"
    secrets:
      UNITY_LICENSE:
        description: 'Unity license'
        required: false
      UNITY_EMAIL:
        description: 'Unity email'
        required: false
      UNITY_PASSWORD:
        description: 'Unity password'
        required: false
    outputs:
        version:
          description: "Computed version string"
          value: ${{ jobs.build-unity.outputs.version }}
        version-code:
          description: "Computed Android versionCode"
          value: ${{ jobs.build-unity.outputs.version-code }}
        strategy:
          description: "Version strategy used (semantic|hash)"
          value: ${{ jobs.build-unity.outputs.strategy }}
        apk_path:
          description: "Built APK path (in the runner workspace)"
          value: ${{ jobs.build-unity.outputs.apk_path }}

jobs:
  build-unity:
    runs-on: [self-hosted, Windows]
    outputs:
      version: ${{ steps.set-version.outputs.version }}
      version-code: ${{ steps.set-version.outputs['version-code'] }}
      strategy: ${{ steps.set-version.outputs.strategy }}
      apk_path: ${{ steps.unity-build.outputs.apk_path }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          lfs: true

      - name: Determine version strategy
        id: set-version
        shell: pwsh
        run: |
          # Read inputs as strings (may be empty in workflow_call)
          $year  = "${{ inputs.versionYear }}"
          $major = "${{ inputs.versionMajor }}"
          $minor = "${{ inputs.versionMinor }}"
          $patch = "${{ inputs.versionPatch }}"
          $vtype = "${{ inputs.versionType }}"
          $isDevInput = "${{ inputs.devBuild }}"
      
          $haveSem = -not [string]::IsNullOrWhiteSpace($year) `
                     -and -not [string]::IsNullOrWhiteSpace($major) `
                     -and -not [string]::IsNullOrWhiteSpace($minor) `
                     -and -not [string]::IsNullOrWhiteSpace($patch)
      
          if ($haveSem) {
            # Semantic versioning: YEAR.MAJOR.MINOR.PATCH[-TYPE]
            $version = "$year.$major.$minor.$patch"
            if (-not [string]::IsNullOrWhiteSpace($vtype)) { $version = "$version-$vtype" }
      
            # Android versionCode = (YEAR-2020)*100000000 + MAJOR*1000000 + MINOR*1000 + PATCH
            $yearI  = [int]$year
            $majorI = [int]$major
            $minorI = [int]$minor
            $patchI = [int]$patch
            $code   = (($yearI - 2020) * 100000000) + ($majorI * 1000000) + ($minorI * 1000) + $patchI
            $strategy = 'semantic'
          } else {
            # Hash-based: <7-char-hash>-dev  and versionCode = 1_000_000 + commitCount
            $commitHash  = (git rev-parse --short=7 HEAD).Trim()
            $commitCount = [int](git rev-list --count HEAD)
            $version = "$commitHash-dev"
            $code    = 1000000 + $commitCount
            $strategy = 'hash'
          }
      
          # Optional development flag passthrough
          $isDev = ($isDevInput.ToString().ToLower() -eq 'true')
      
          # ---- Step outputs expected by new logic ----
          "strategy=$strategy"          | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          "version=$version"            | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          "version-code=$code"          | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
      
          # ---- Back-compat outputs for the rest of your workflow ----
          "QUESTNAV_VERSION=$version"       | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          "QUESTNAV_VERSION_CODE=$code"     | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          if ($isDev) {
            "QUESTNAV_DEVELOPMENT_BUILD=1"  | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          }
      
          # ---- Also export to env for subsequent steps ----
          "QUESTNAV_VERSION=$version"       | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          "QUESTNAV_VERSION_CODE=$code"     | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          if ($isDev) {
            "QUESTNAV_DEVELOPMENT_BUILD=1"  | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          }

      - name: Resolve Unity.exe
        id: unity-path
        shell: pwsh
        run: |
          $unity = $env:UNITY_EDITOR_PATH
          
          if (-not $unity) {
            # Try unityVersion from workflow input
            $version = "${{ inputs.unityVersion }}"
            if ($version) {
              Write-Host "Using Unity version from workflow input: $version"
              $candidate = "C:\Program Files\Unity\Hub\Editor\$version\Editor\Unity.exe"
              if (Test-Path $candidate) { 
                $unity = $candidate 
                Write-Host "Found Unity at: $unity"
              } else {
                Write-Warning "Unity $version not found at: $candidate"
              }
            }
          }
          
          if (-not $unity) {
            # Try reading from ProjectVersion.txt
            $versionFile = "unity\ProjectSettings\ProjectVersion.txt"
            if (Test-Path $versionFile) {
              $content = Get-Content $versionFile -Raw
              $m = [regex]::Match($content, "m_EditorVersion:\s*([0-9\.a-zA-Z\-]+)")
              if ($m.Success) {
                $version = $m.Groups[1].Value
                Write-Host "Using Unity version from ProjectVersion.txt: $version"
                $candidate = "C:\Program Files\Unity\Hub\Editor\$version\Editor\Unity.exe"
                if (Test-Path $candidate) { 
                  $unity = $candidate
                  Write-Host "Found Unity at: $unity"
                }
              }
            }
          }
          
          if (-not $unity) {
            throw "Unity Editor not found. Please install Unity ${{ inputs.unityVersion }} or set UNITY_EDITOR_PATH environment variable."
          }
          
          Write-Host "Using Unity Editor: $unity"
          "UNITY_EDITOR_PATH=$unity" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

      - name: Clean Unity artifacts
        shell: pwsh
        run: |
          $proj = "unity"
          @('Library','Temp','obj','Logs','build') | ForEach-Object {
            $p = Join-Path $proj $_
            if (Test-Path $p) {
              try {
                Remove-Item -Recurse -Force -LiteralPath -ErrorAction Stop $p
                Write-Host "Removed: $p"
              } catch {
                # Either wrap the var...
                # Write-Warning "Failed to remove $($p): $($_.Exception.Message)"
                # ...or use -f formatting (recommended)
                Write-Warning ("Failed to remove {0}: {1}" -f $p, $_.Exception.Message)
              }
            }
          }

      - name: Verify Unity Android modules
        shell: pwsh
        run: |
          $editorDir = Split-Path $env:UNITY_EDITOR_PATH -Parent
          $android   = Join-Path $editorDir 'Data\PlaybackEngines\AndroidPlayer'
          if (-not (Test-Path $android)) { Write-Error "Missing AndroidPlayer folder: $android"; exit 1 }
      
          $ok = $true
          $paths = @(
            'SDK',         # Embedded Android SDK
            'NDK',         # Embedded NDK
            'OpenJDK',     # Embedded JDK
            'Tools\gradle' # Gradle lives here in modern Unity
          ) | ForEach-Object { Join-Path $android $_ }
      
          foreach ($p in $paths) {
            if (-not (Test-Path $p)) {
              Write-Warning "Android component missing (or different layout): $p"
              $ok = $false
            }
          }
      
          # Legacy fallback: some versions used ...\AndroidPlayer\Gradle
          $legacyGradle = Join-Path $android 'Gradle'
          if (-not (Test-Path (Join-Path $android 'Tools\gradle')) -and (Test-Path $legacyGradle)) {
            Write-Host "Using legacy Gradle path: $legacyGradle"
            $ok = $true
          }
      
          Write-Host "AndroidPlayer contents:"
          Get-ChildItem $android -Depth 2 | Select-Object FullName, PSIsContainer | Format-Table -AutoSize
      
          if (-not $ok) { Write-Error "Android modules look incomplete for this Unity install."; exit 1 }

      - name: Accept Android SDK Licenses
        shell: pwsh
        run: |
          $editorDir = Split-Path $env:UNITY_EDITOR_PATH -Parent
          $sdkPath = Join-Path $editorDir 'Data\PlaybackEngines\AndroidPlayer\SDK'
          $licensesDir = Join-Path $sdkPath 'licenses'
          
          Write-Host "Creating Android SDK license files in: $licensesDir"
          New-Item -ItemType Directory -Force -Path $licensesDir | Out-Null
          
          # Android SDK License (most common)
          $licenseContent = "24333f8a63b6825ea9c5514f83c2829b004d1fee"
          Set-Content -Path (Join-Path $licensesDir 'android-sdk-license') -Value $licenseContent -NoNewline -Encoding ASCII
          Write-Host "Created android-sdk-license"
          
          # Android SDK Preview License
          $previewLicenseContent = "84831b9409646a918e30573bab4c9c91346d8abd"
          Set-Content -Path (Join-Path $licensesDir 'android-sdk-preview-license') -Value $previewLicenseContent -NoNewline -Encoding ASCII
          Write-Host "Created android-sdk-preview-license"
          
          # Intel Android Extra License (sometimes needed)
          Set-Content -Path (Join-Path $licensesDir 'intel-android-extra-license') -Value $licenseContent -NoNewline -Encoding ASCII
          Write-Host "Created intel-android-extra-license"
          
          Write-Host "Android SDK licenses accepted successfully"

      - name: Build with Unity (stream logs)
        id: unity-build
        timeout-minutes: 90
        shell: pwsh
        env:
          OVR_DISABLE_PROJECT_SETUP: "1"
          UPM_LOG_LEVEL: debug
        run: |
          $proj    = "unity"
          $unity   = $env:UNITY_EDITOR_PATH
          $logPath = Join-Path $PWD "local-unity-build.log"
          if (Test-Path $logPath) { Remove-Item $logPath -Force }
      
          # We'll tee console output into a file for artifact upload
          $args = @(
            '-batchmode','-nographics','-quit',
            '-accept-apiupdate',               # avoid API Updater prompt
            '-enablePackageManagerTraces',     # extra package manager logs
            '-buildTarget','Android',          # make target explicit
            '-projectPath', $proj,
            '-executeMethod','CI.Build.PerformAndroid',
            '-logFile','-'                     # <-- stream to stdout
          )
      
          # Run Unity and tee output to our log file
          # (&) blocks until Unity exits; $LASTEXITCODE will have Unity's exit code
          & "$unity" @args 2>&1 | Tee-Object -FilePath $logPath
          $exit = $LASTEXITCODE
      
          Write-Host "---- Tail of Unity log (from file) ----"
          if (Test-Path $logPath) { Get-Content $logPath -Tail 200 } else { Write-Warning "Unity log file not found at $logPath" }
          if ($exit -ne 0) { throw "Unity build failed with exit code $exit. See $logPath" }
      
          # Short post-exit grace period for file flush
          $apk = Join-Path $proj "build/Android/QuestNav-local.apk"
          for ($i=0; $i -lt 30 -and -not (Test-Path $apk); $i++) { Start-Sleep -Seconds 1 }
      
          if (-not (Test-Path $apk)) { throw "Expected APK not found at $apk. See $logPath" }
          "APK_PATH=$apk" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
        
        
      - name: Compute artifact name
        id: artifact
        shell: pwsh
        run: |
          $name = "QuestNav-${{ steps.set-version.outputs.version }}-${{ steps.set-version.outputs['version-code'] }}"
          if ("${{ inputs.devBuild }}".ToLower() -eq "true") { $name = "$name-dev" }
          "ARTIFACT_NAME=$name" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: Upload APK
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.artifact.outputs.ARTIFACT_NAME }}
          path: ${{ steps.unity-build.outputs.APK_PATH }}
          if-no-files-found: error

      - name: Upload Unity build log
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: unity-build-log-${{ steps.set-version.outputs.version }}
          path: local-unity-build.log
          retention-days: 7

      - name: Upload diagnostics
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: unity-diagnostics-${{ steps.set-version.outputs.version || 'unknown' }}
          if-no-files-found: warn
          retention-days: 7
          path: |
            local-unity-build.log
            ${{ env.LOCALAPPDATA }}\Unity\Editor\Editor.log
            ${{ env.LOCALAPPDATA }}\Unity\cache\logs\*
            ${{ env.APPDATA }}\Unity\Packages\logs\*
            unity\Library\**\*.log
            unity\Logs\**\*
            ${{ env.LOCALAPPDATA }}\Temp\Unity\Editor\Crashes\**

      - name: Preserve XML Documentation
        shell: pwsh
        run: |
          Write-Host "Preserving XML documentation file for DocFX..."
          $xmlPath = "unity/Library/ScriptAssemblies/QuestNav.xml"
          if (Test-Path $xmlPath) {
            Write-Host "Found QuestNav.xml, copying to persistent location..."
            New-Item -ItemType Directory -Force -Path "unity/DocFX/preserved-xml" | Out-Null
            Copy-Item $xmlPath "unity/DocFX/preserved-xml/QuestNav.xml" -Force
            Write-Host "XML documentation preserved at unity/DocFX/preserved-xml/QuestNav.xml"
            Get-ChildItem "unity/DocFX/preserved-xml/" | Format-Table -AutoSize
          }
          else {
            Write-Warning "QuestNav.xml not found at $xmlPath"
            Write-Host "Available files in ScriptAssemblies:"
            Get-ChildItem "unity/Library/ScriptAssemblies/" -File | Where-Object { $_.Extension -in '.xml','.dll' } | Format-Table -AutoSize
          }

      - name: Upload XML Documentation Artifact
        uses: actions/upload-artifact@v4
        if: success()
        with:
          name: questnav-xml-docs-${{ steps.set-version.outputs.version }}
          path: unity/DocFX/preserved-xml/QuestNav.xml
          retention-days: 30

  # Call DocFX workflow after successful Unity build
  build-docfx:
    name: Generate C# API Documentation
    needs: build-unity
    if: success()
    uses: ./.github/workflows/build-docfx-api.yml
    with:
      unity-build-completed: true
    permissions:
      contents: write
      pull-requests: write

  # Call Javadoc workflow after successful Unity build
  build-javadoc:
    name: Generate Java API Documentation
    needs: build-unity
    if: success()
    uses: ./.github/workflows/build-javadoc-api.yml
    with:
      unity-build-completed: true
    permissions:
      contents: write
      pull-requests: write