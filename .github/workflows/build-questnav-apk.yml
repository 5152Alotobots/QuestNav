name: Build QuestNav App
on:
  workflow_call:
    inputs:
      versionYear:
        description: 'Current FRC Year'
        required: false
        type: string
      versionMajor:
        description: 'Major version'
        required: false
        type: string
      versionMinor:
        description: 'Minor version'
        required: false
        type: string
      versionPatch:
        description: 'Patch version'
        required: false
        type: string
      versionType:
        description: 'Type of version'
        required: false
        type: string
    secrets:
      UNITY_LICENSE:
        description: 'Unity License'
        required: true
      UNITY_EMAIL:
        description: 'Unity Email'
        required: true
      UNITY_PASSWORD:
        description: 'Unity Password'
        required: true
    outputs:
      apk-artifact-name:
        description: "Name of the uploaded APK artifact"
        value: ${{ jobs.build-unity.outputs.apk-artifact-name }}
      apk-filename:
        description: "Filename of the built APK"
        value: ${{ jobs.build-unity.outputs.apk-filename }}

jobs:
  build-unity:
    runs-on: [self-hosted, windows, x64]
    outputs:
      apk-artifact-name: ${{ steps.upload.outputs.artifact-id }}
      apk-filename: ${{ steps.version-info.outputs.version }}.apk
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha || github.ref }}
          sparse-checkout: unity
          sparse-checkout-cone-mode: false
          lfs: true

      - name: Determine Version Strategy
        id: version-info
        shell: pwsh
        run: |
          if ('${{ inputs.versionYear }}' -ne '' -and '${{ inputs.versionMajor }}' -ne '' -and '${{ inputs.versionMinor }}' -ne '' -and '${{ inputs.versionPatch }}' -ne '') {
            $VERSION = "${{ inputs.versionYear }}.${{ inputs.versionMajor }}.${{ inputs.versionMinor }}.${{ inputs.versionPatch }}"
            if ('${{ inputs.versionType }}' -ne '') { $VERSION = "$VERSION-${{ inputs.versionType }}" }
            $YEAR = [int]'${{ inputs.versionYear }}'
            $MAJOR = [int]'${{ inputs.versionMajor }}'
            $MINOR = [int]'${{ inputs.versionMinor }}'
            $PATCH = [int]'${{ inputs.versionPatch }}'
            $VERSION_CODE = (($YEAR - 2020) * 100000000 + $MAJOR * 1000000 + $MINOR * 1000 + $PATCH)
            "strategy=semantic" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
            "version=$VERSION" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
            "version-code=$VERSION_CODE" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          }
          else {
            $COMMIT_HASH = (git rev-parse --short=7 HEAD).Trim()
            $VERSION = "$COMMIT_HASH-dev"
            $COMMIT_COUNT = [int](git rev-list --count HEAD)
            $VERSION_CODE = 1000000 + $COMMIT_COUNT
            "strategy=hash" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
            "version=$VERSION" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
            "version-code=$VERSION_CODE" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          }

      # (Windows runners generally have sufficient space; skip linux-only disk cleanup)

      - name: Setup Caching
        uses: actions/cache@v3
        with:
          path: unity/Library
          key: Library-QuestNav-Android
          restore-keys: |
            Library-
            Library-Questnav-

      # .NET 8.x is pre-installed on the self-hosted Windows runner
      # - name: Setup .NET
      #   uses: actions/setup-dotnet@v4
      #   with:
      #     dotnet-version: '8.x'

      # NuGetForUnity is pre-installed on the self-hosted Windows runner
      # - name: Install NuGetForUnity
      #   run: dotnet tool install --global NuGetForUnity.Cli

      - name: Restore NuGetForUnity Packages
        shell: pwsh
        run: "& $env:USERPROFILE\\.dotnet\\tools\\nugetforunity.exe restore unity/"

      - name: Ensure sh is available
        shell: pwsh
        run: |
          if (-not (Test-Path "$env:ProgramFiles\Git\usr\bin\sh.exe")) {
            throw "sh.exe not found. Install Git for Windows on this runner."
          }
          "$env:ProgramFiles\Git\usr\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          & "$env:ProgramFiles\Git\usr\bin\sh.exe" --version

      - name: Discover local Unity editor
        shell: pwsh
        run: |
          $projVersionPath = "unity/ProjectSettings/ProjectVersion.txt"
          if (-not (Test-Path $projVersionPath)) { throw "ProjectVersion.txt not found at $projVersionPath" }
          $versionLine = (Select-String -Path $projVersionPath -Pattern '^m_EditorVersion:\s*(.+)$').Matches[0].Groups[1].Value
          if (-not $versionLine) { throw "Unable to read Unity version from ProjectVersion.txt" }
          $candidates = @(
            "C:\\Program Files\\Unity\\Hub\\Editor\\$versionLine\\Editor\\Unity.exe",
            "C:\\Program Files\\Unity\\Editor\\$versionLine\\Editor\\Unity.exe"
          )
          $unityPath = $null
          foreach ($p in $candidates) { if (Test-Path $p) { $unityPath = $p; break } }
          if (-not $unityPath) { throw "Unity $versionLine not found in standard locations. Install via Unity Hub or adjust the path." }
          "UNITY_EDITOR_PATH=$unityPath" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

      - name: Build (Unity batchmode, no Docker)
        shell: pwsh
        env:
          UNITY_EDITOR_PATH: ${{ env.UNITY_EDITOR_PATH }}
          QUESTNAV_VERSION:  ${{ steps.version-info.outputs.version }}
          QUESTNAV_VERSION_CODE: ${{ steps.version-info.outputs.version-code }}
          OVR_DISABLE_PROJECT_SETUP: 1
        run: |
          $unity = "$env:UNITY_EDITOR_PATH"
          if (-not (Test-Path $unity)) { throw "Unity editor not found at $unity" }
          & $unity -quit -batchmode -nographics `
            -projectPath "unity" `
            -executeMethod "CI.Build.PerformAndroid" `
            -buildTarget Android `
            -logFile "$PWD/unity_build.log" `
            -customBuildName "QuestNav" `
            -customBuildPath "$PWD/build/Android/QuestNav-${{ steps.version-info.outputs.version }}.apk" `
            -customBuildVersion "$env:QUESTNAV_VERSION" `
            -customBuildVersionCode "$env:QUESTNAV_VERSION_CODE"

      - name: Preserve XML Documentation
        shell: pwsh
        run: |
          Write-Host "Preserving XML documentation file for DocFX..."
          $xmlPath = "unity/Library/ScriptAssemblies/QuestNav.xml"
          if (Test-Path $xmlPath) {
            Write-Host "Found QuestNav.xml, copying to persistent location..."
            New-Item -ItemType Directory -Force -Path "unity/DocFX/preserved-xml" | Out-Null
            Copy-Item $xmlPath "unity/DocFX/preserved-xml/QuestNav.xml" -Force
            Write-Host "XML documentation preserved at unity/DocFX/preserved-xml/QuestNav.xml"
            Get-ChildItem "unity/DocFX/preserved-xml/" | Format-Table -AutoSize
          }
          else {
            Write-Warning "QuestNav.xml not found at $xmlPath"
            Write-Host "Available files in ScriptAssemblies:"
            Get-ChildItem "unity/Library/ScriptAssemblies/" -File | Where-Object { $_.Extension -in '.xml','.dll' } | Format-Table -AutoSize
          }

      - name: Upload XML Documentation Artifact
        uses: actions/upload-artifact@v4
        if: success()
        with:
          name: questnav-xml-docs-${{ steps.version-info.outputs.version }}
          path: unity/DocFX/preserved-xml/QuestNav.xml
          retention-days: 30

      - name: Upload APK Artifact
        uses: actions/upload-artifact@v4
        id: upload
        with:
          name: questnav-apk-${{ steps.version-info.outputs.version }}
          path: build/Android/*.apk
          retention-days: 7

  # Call DocFX workflow after successful Unity build
  build-docfx:
    name: Generate C# API Documentation
    needs: build-unity
    if: success()
    uses: ./.github/workflows/build-docfx-api.yml
    with:
      unity-build-completed: true
    permissions:
      contents: write
      pull-requests: write

  # Call Javadoc workflow after successful Unity build
  build-javadoc:
    name: Generate Java API Documentation
    needs: build-unity
    if: success()
    uses: ./.github/workflows/build-javadoc-api.yml
    with:
      unity-build-completed: true
    permissions:
      contents: write
      pull-requests: write