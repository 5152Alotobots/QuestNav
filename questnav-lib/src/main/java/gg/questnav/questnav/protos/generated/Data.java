// Code generated by protocol buffer compiler. Do not edit!
package gg.questnav.questnav.protos.generated;

import edu.wpi.first.math.proto.Geometry2D;
import java.io.IOException;
import us.hebi.quickbuf.Descriptors;
import us.hebi.quickbuf.FieldName;
import us.hebi.quickbuf.InvalidProtocolBufferException;
import us.hebi.quickbuf.JsonSink;
import us.hebi.quickbuf.JsonSource;
import us.hebi.quickbuf.MessageFactory;
import us.hebi.quickbuf.ProtoMessage;
import us.hebi.quickbuf.ProtoSink;
import us.hebi.quickbuf.ProtoSource;
import us.hebi.quickbuf.ProtoUtil;
import us.hebi.quickbuf.RepeatedByte;

public final class Data {
    private static final RepeatedByte descriptorData = ProtoUtil.decodeBase64(6850,
        "CgpkYXRhLnByb3RvEhRxdWVzdG5hdi5wcm90b3MuZGF0YRoQZ2VvbWV0cnkyZC5wcm90byKNAQoZUHJv" + 
        "dG9idWZRdWVzdE5hdkZyYW1lRGF0YRIfCgtmcmFtZV9jb3VudBgBIAEoBVIKZnJhbWVDb3VudBIcCgl0" + 
        "aW1lc3RhbXAYAiABKAFSCXRpbWVzdGFtcBIxCgZwb3NlMmQYAyABKAsyGS53cGkucHJvdG8uUHJvdG9i" + 
        "dWZQb3NlMmRSBnBvc2UyZCKoAQoaUHJvdG9idWZRdWVzdE5hdkRldmljZURhdGESMgoVdHJhY2tpbmdf" + 
        "bG9zdF9jb3VudGVyGAEgASgFUhN0cmFja2luZ0xvc3RDb3VudGVyEi0KEmN1cnJlbnRseV90cmFja2lu" + 
        "ZxgCIAEoCFIRY3VycmVudGx5VHJhY2tpbmcSJwoPYmF0dGVyeV9wZXJjZW50GAMgASgFUg5iYXR0ZXJ5" + 
        "UGVyY2VudEJDCiVnZy5xdWVzdG5hdi5xdWVzdG5hdi5wcm90b3MuZ2VuZXJhdGVkqgIZUXVlc3ROYXYu" + 
        "UHJvdG9zLkdlbmVyYXRlZEqDMgoHEgUAA7wBAQoICgEMEgMAAxUK8wYKAQISAxYAHTLoBioKIFF1ZXN0" + 
        "TmF2IERhdGEgUHJvdG9jb2wgQnVmZmVyIERlZmluaXRpb25zCiAKIFRoaXMgZmlsZSBkZWZpbmVzIHRo" + 
        "ZSBkYXRhIHN0cnVjdHVyZXMgdXNlZCBmb3IgdHJhbnNtaXR0aW5nIHRyYWNraW5nIGFuZCBkZXZpY2UK" + 
        "IGluZm9ybWF0aW9uIGZyb20gdGhlIFF1ZXN0IGhlYWRzZXQgdG8gZXh0ZXJuYWwgc3lzdGVtcyAoc3Vj" + 
        "aCBhcyByb2JvdCBjb2RlKS4KIFRoZSBkYXRhIGlzIG9yZ2FuaXplZCBpbnRvIHR3byBtYWluIGNhdGVn" + 
        "b3JpZXMgd2l0aCBkaWZmZXJlbnQgdXBkYXRlIGZyZXF1ZW5jaWVzOgogCiAxLiBGcmFtZSBEYXRhOiBI" + 
        "aWdoLWZyZXF1ZW5jeSB0cmFja2luZyBpbmZvcm1hdGlvbiAocG9zZSwgdGltZXN0YW1wcykKIDIuIERl" + 
        "dmljZSBEYXRhOiBMb3dlci1mcmVxdWVuY3kgZGV2aWNlIHN0YXR1cyBpbmZvcm1hdGlvbiAoYmF0dGVy" + 
        "eSwgdHJhY2tpbmcgc3RhdGUpCiAKIFRoaXMgc2VwYXJhdGlvbiBhbGxvd3MgZm9yIGVmZmljaWVudCBi" + 
        "YW5kd2lkdGggdXNhZ2UgYnkgc2VuZGluZyBjcml0aWNhbCB0cmFja2luZwogZGF0YSBmcmVxdWVudGx5" + 
        "IHdoaWxlIHNlbmRpbmcgbGVzcyBjcml0aWNhbCBkZXZpY2Ugc3RhdHVzIGRhdGEgYXQgYSBsb3dlciBy" + 
        "YXRlLgogCiBEYXRhIEZsb3c6CiAtIFF1ZXN0IGNvbnRpbnVvdXNseSBwcm9jZXNzZXMgY2FtZXJhL3Nl" + 
        "bnNvciBkYXRhCiAtIEZyYW1lIGRhdGEgaXMgc2VudCBldmVyeSB0cmFja2luZyB1cGRhdGUgKHR5cGlj",
        "YWxseSAzMC05MCBIeikKIC0gRGV2aWNlIGRhdGEgaXMgc2VudCBwZXJpb2RpY2FsbHkgKHR5cGljYWxs" + 
        "eSAxLTEwIEh6KQogLSBFeHRlcm5hbCBzeXN0ZW1zIHJlY2VpdmUgYW5kIHByb2Nlc3MgdGhpcyBkYXRh" + 
        "IGZvciByb2JvdCBsb2NhbGl6YXRpb24KCggKAQgSAxcANgoJCgIIJRIDFwA2CggKAQgSAxgAPgoJCgII" + 
        "ARIDGAA+Cj0KAgMAEgMbABoaMiBJbXBvcnQgZ2VvbWV0cnkgbWVzc2FnZXMgZm9yIHBvc2UgcmVwcmVz" + 
        "ZW50YXRpb24KCuEFCgIEABIELgBlARrUBSoKIEhpZ2gtZnJlcXVlbmN5IHRyYWNraW5nIGRhdGEgc2Vu" + 
        "dCBmcm9tIFF1ZXN0IHRvIGV4dGVybmFsIHN5c3RlbXMuCiAKIFRoaXMgbWVzc2FnZSBjb250YWlucyB0" + 
        "aGUgY29yZSB0cmFja2luZyBpbmZvcm1hdGlvbiB0aGF0IGV4dGVybmFsIHN5c3RlbXMKIChsaWtlIHJv" + 
        "Ym90IGNvZGUpIG5lZWQgZm9yIHJlYWwtdGltZSBsb2NhbGl6YXRpb24gYW5kIG5hdmlnYXRpb24uIEl0" + 
        "J3Mgc2VudAogYXQgaGlnaCBmcmVxdWVuY3kgKHR5cGljYWxseSAzMC05MCBIeikgdG8gcHJvdmlkZSBz" + 
        "bW9vdGgsIHJlc3BvbnNpdmUgdHJhY2tpbmcuCiAKIFRoZSBkYXRhIHJlcHJlc2VudHMgdGhlIFF1ZXN0" + 
        "J3MgdW5kZXJzdGFuZGluZyBvZiB0aGUgcm9ib3QncyBwb3NpdGlvbiBhbmQKIG9yaWVudGF0aW9uIG9u" + 
        "IHRoZSBmaWVsZCwgZGVyaXZlZCBmcm9tIHZpc3VhbC1pbmVydGlhbCBvZG9tZXRyeSB1c2luZyB0aGUK" + 
        "IFF1ZXN0J3MgY2FtZXJhcyBhbmQgSU1VIHNlbnNvcnMuCiAKIENvb3JkaW5hdGUgU3lzdGVtOgogLSBV" + 
        "c2VzIFdQSUxpYiBmaWVsZC1yZWxhdGl2ZSBjb29yZGluYXRlIHN5c3RlbQogLSBPcmlnaW4gYW5kIGF4" + 
        "ZXMgZGVwZW5kIG9uIGZpZWxkIHNldHVwIGFuZCBjYWxpYnJhdGlvbgogLSBQb3NlIHJlcHJlc2VudHMg" + 
        "dGhlIHJvYm90J3MgcG9zaXRpb24sIG5vdCB0aGUgUXVlc3QncyBwb3NpdGlvbgogICAoYWNjb3VudGlu" + 
        "ZyBmb3IgUXVlc3QgbW91bnRpbmcgb2Zmc2V0KQoKCgoDBAABEgMuCCEKyAMKBAQAAgASAzwCGBq6AyoK" + 
        "IFNlcXVlbnRpYWwgZnJhbWUgY291bnRlciBmb3IgdGhpcyB0cmFja2luZyBzZXNzaW9uLgogCiBUaGlz" + 
        "IGNvdW50ZXIgaW5jcmVtZW50cyB3aXRoIGVhY2ggZnJhbWUgcHJvY2Vzc2VkIGJ5IHRoZSBRdWVzdCdz" + 
        "IHRyYWNraW5nCiBzeXN0ZW0uIEl0IGNhbiBiZSB1c2VkIHRvOgogLSBEZXRlY3QgZHJvcHBlZCBvciBv",
        "dXQtb2Ytb3JkZXIgbWVzc2FnZXMKIC0gQ2FsY3VsYXRlIGVmZmVjdGl2ZSBmcmFtZSByYXRlCiAtIFN5" + 
        "bmNocm9uaXplIHdpdGggb3RoZXIgZGF0YSBzdHJlYW1zCiAKIFRoZSBjb3VudGVyIHJlc2V0cyB0byAw" + 
        "IHdoZW4gdGhlIFF1ZXN0TmF2IGFwcCBzdGFydHMgYW5kIGluY3JlbWVudHMKIGNvbnRpbnVvdXNseSBk" + 
        "dXJpbmcgb3BlcmF0aW9uLiBGcmFtZSBkcm9wcyBpbiB0cmFuc21pc3Npb24gd2lsbCBjcmVhdGUKIGdh" + 
        "cHMgaW4gdGhlIHNlcXVlbmNlLgoKDAoFBAACAAUSAzwCBwoMCgUEAAIAARIDPAgTCgwKBQQAAgADEgM8" + 
        "FhcK3wMKBAQAAgESA00CFxrRAyoKIFRpbWVzdGFtcCBpbiBzZWNvbmRzIHNpbmNlIFF1ZXN0TmF2IGFw" + 
        "cCBzdGFydHVwLgogCiBUaGlzIHByb3ZpZGVzIHRpbWluZyBpbmZvcm1hdGlvbiBmb3IgdGhlIHRyYWNr" + 
        "aW5nIGRhdGEsIGFsbG93aW5nIGV4dGVybmFsCiBzeXN0ZW1zIHRvOgogLSBDYWxjdWxhdGUgZGF0YSBh" + 
        "Z2UgYW5kIGxhdGVuY3kKIC0gSW50ZXJwb2xhdGUgb3IgZXh0cmFwb2xhdGUgcG9zZXMgZm9yIHByZWRp" + 
        "Y3Rpb24KIC0gU3luY2hyb25pemUgd2l0aCBvdGhlciBzZW5zb3IgZGF0YQogLSBJbXBsZW1lbnQgdGlt" + 
        "ZW91dCBkZXRlY3Rpb24KIAogVGhlIHRpbWVzdGFtcCBpcyByZWxhdGl2ZSB0byBhcHAgc3RhcnR1cCwg" + 
        "bm90IHN5c3RlbSB0aW1lLCB0byBhdm9pZAogY2xvY2sgc3luY2hyb25pemF0aW9uIGlzc3VlcyBiZXR3" + 
        "ZWVuIGRldmljZXMuCiAKIFJlc29sdXRpb246IFR5cGljYWxseSBzdWItbWlsbGlzZWNvbmQgcHJlY2lz" + 
        "aW9uCgoMCgUEAAIBBRIDTQIICgwKBQQAAgEBEgNNCRIKDAoFBAACAQMSA00VFgrUBQoEBAACAhIDZAIm" + 
        "GsYFKgogUm9ib3QncyAyRCBwb3NlIG9uIHRoZSBmaWVsZCBpbiBXUElMaWIgY29vcmRpbmF0ZXMuCiAK" + 
        "IFRoaXMgcmVwcmVzZW50cyB0aGUgcm9ib3QncyBwb3NpdGlvbiBhbmQgb3JpZW50YXRpb24gYXMgZGV0" + 
        "ZXJtaW5lZCBieQogdGhlIFF1ZXN0J3MgdHJhY2tpbmcgc3lzdGVtLiBUaGUgcG9zZSBhY2NvdW50cyBm" + 
        "b3I6CiAtIFF1ZXN0IG1vdW50aW5nIHBvc2l0aW9uL29yaWVudGF0aW9uIHJlbGF0aXZlIHRvIHJvYm90" + 
        "IGNlbnRlcgogLSBDb29yZGluYXRlIHN5c3RlbSB0cmFuc2Zvcm1hdGlvbiB0byBXUElMaWIgc3RhbmRh" + 
        "cmQKIC0gQW55IGNhbGlicmF0aW9uIG9mZnNldHMgYXBwbGllZAogCiBDb29yZGluYXRlIFN5c3RlbSBE",
        "ZXRhaWxzOgogLSBYOiBGb3J3YXJkIGRpcmVjdGlvbiAodG93YXJkcyBvcHBvc2luZyBhbGxpYW5jZSkK" + 
        "IC0gWTogTGVmdCBkaXJlY3Rpb24gKHdoZW4gZmFjaW5nIGZvcndhcmQpICAKIC0gUm90YXRpb246IENv" + 
        "dW50ZXItY2xvY2t3aXNlIHBvc2l0aXZlIChyYWRpYW5zKQogLSBVbml0czogbWV0ZXJzIGZvciB0cmFu" + 
        "c2xhdGlvbiwgcmFkaWFucyBmb3Igcm90YXRpb24KIAogQWNjdXJhY3kgZGVwZW5kcyBvbjoKIC0gRW52" + 
        "aXJvbm1lbnRhbCBsaWdodGluZyBhbmQgZmVhdHVyZXMKIC0gUXVlc3QgdHJhY2tpbmcgcXVhbGl0eQog" + 
        "LSBDYWxpYnJhdGlvbiBhY2N1cmFjeQogLSBUaW1lIHNpbmNlIGxhc3QgcG9zZSByZXNldAoKDAoFBAAC" + 
        "AgYSA2QCGgoMCgUEAAICARIDZBshCgwKBQQAAgIDEgNkJCUK5gQKAgQBEgV4ALwBARrYBCoKIExvd2Vy" + 
        "LWZyZXF1ZW5jeSBkZXZpY2Ugc3RhdHVzIGRhdGEgc2VudCBmcm9tIFF1ZXN0IHRvIGV4dGVybmFsIHN5" + 
        "c3RlbXMuCiAKIFRoaXMgbWVzc2FnZSBjb250YWlucyBkZXZpY2UgaGVhbHRoIGFuZCBzdGF0dXMgaW5m" + 
        "b3JtYXRpb24gdGhhdCBkb2Vzbid0IG5lZWQKIHRvIGJlIHNlbnQgYXMgZnJlcXVlbnRseSBhcyB0cmFj" + 
        "a2luZyBkYXRhLiBJdCdzIHR5cGljYWxseSBzZW50IGF0IDEtMTAgSHoKIHRvIHByb3ZpZGUgbW9uaXRv" + 
        "cmluZyBhbmQgZGlhZ25vc3RpYyBpbmZvcm1hdGlvbiB3aXRob3V0IGNvbnN1bWluZyBleGNlc3NpdmUK" + 
        "IGJhbmR3aWR0aC4KIAogVGhpcyBkYXRhIGhlbHBzIGV4dGVybmFsIHN5c3RlbXM6CiAtIE1vbml0b3Ig" + 
        "UXVlc3QgZGV2aWNlIGhlYWx0aAogLSBEZXRlY3QgdHJhY2tpbmcgc3lzdGVtIGlzc3VlcwogLSBJbXBs" + 
        "ZW1lbnQgZmFpbHNhZmUgYmVoYXZpb3JzCiAtIFByb3ZpZGUgdXNlciBmZWVkYmFjayBhYm91dCBzeXN0" + 
        "ZW0gc3RhdHVzCiAKIFRoZSBpbmZvcm1hdGlvbiBpcyB1c2VmdWwgZm9yIGJvdGggYXV0b25vbW91cyBv" + 
        "cGVyYXRpb24gYW5kIGRlYnVnZ2luZy8KIHRyb3VibGVzaG9vdGluZyBzY2VuYXJpb3MuCgoKCgMEAQES" + 
        "A3gIIgqGBQoEBAECABIEjAECIhr3BCoKIENvdW50IG9mIHRyYWNraW5nIGxvc3MgZXZlbnRzIHNpbmNl" + 
        "IGFwcCBzdGFydHVwLgogCiBUaGlzIGNvdW50ZXIgaW5jcmVtZW50cyBlYWNoIHRpbWUgdGhlIFF1ZXN0" + 
        "J3MgdHJhY2tpbmcgc3lzdGVtIGxvc2VzCiB0cmFja2luZyBhZnRlciBoYXZpbmcgZXN0YWJsaXNoZWQg",
        "aXQuIFRyYWNraW5nIGxvc3MgY2FuIG9jY3VyIGR1ZSB0bzoKIC0gUG9vciBsaWdodGluZyBjb25kaXRp" + 
        "b25zCiAtIExhY2sgb2YgdmlzdWFsIGZlYXR1cmVzIGluIGVudmlyb25tZW50CiAtIFJhcGlkIG1vdGlv" + 
        "biBvciBhY2NlbGVyYXRpb24KIC0gT2NjbHVzaW9uIG9mIGNhbWVyYXMKIC0gSGFyZHdhcmUgaXNzdWVz" + 
        "CiAKIEEgaGlnaCBvciByYXBpZGx5IGluY3JlYXNpbmcgY291bnRlciBtYXkgaW5kaWNhdGU6CiAtIEVu" + 
        "dmlyb25tZW50YWwgaXNzdWVzIChsaWdodGluZywgZmVhdHVyZXMpCiAtIFF1ZXN0IG1vdW50aW5nIHBy" + 
        "b2JsZW1zICh2aWJyYXRpb24sIG9ic3RydWN0aW9uKQogLSBIYXJkd2FyZSBkZWdyYWRhdGlvbgogCiBU" + 
        "aGlzIG1ldHJpYyBoZWxwcyBhc3Nlc3MgdHJhY2tpbmcgc3lzdGVtIHJlbGlhYmlsaXR5IGFuZCBjYW4g" + 
        "dHJpZ2dlcgogYWxlcnRzIG9yIGZhbGxiYWNrIGJlaGF2aW9ycyBpbiByb2JvdCBjb2RlLgoKDQoFBAEC" + 
        "AAUSBIwBAgcKDQoFBAECAAESBIwBCB0KDQoFBAECAAMSBIwBICEKugUKBAQBAgESBKIBAh4aqwUqCiBD" + 
        "dXJyZW50IHRyYWNraW5nIHN0YXR1cyBvZiB0aGUgUXVlc3QgZGV2aWNlLgogCiB0cnVlOiAgUXVlc3Qg" + 
        "aXMgYWN0aXZlbHkgdHJhY2tpbmcgYW5kIHBvc2UgZGF0YSBpcyByZWxpYWJsZQogZmFsc2U6IFF1ZXN0" + 
        "IGhhcyBsb3N0IHRyYWNraW5nIGFuZCBwb3NlIGRhdGEgc2hvdWxkIG5vdCBiZSB0cnVzdGVkCiAKIFdo" + 
        "ZW4gdHJhY2tpbmcgaXMgbG9zdDoKIC0gUG9zZSBkYXRhIGJlY29tZXMgc3RhbGUgYW5kIHVucmVsaWFi" + 
        "bGUKIC0gUm9ib3Qgc2hvdWxkIHN3aXRjaCB0byBhbHRlcm5hdGl2ZSBsb2NhbGl6YXRpb24gbWV0aG9k" + 
        "cwogLSBNb3ZlbWVudCBzaG91bGQgYmUgbGltaXRlZCBvciBzdG9wcGVkIGZvciBzYWZldHkKIAogVHJh" + 
        "Y2tpbmcgY2FuIGJlIHJlY292ZXJlZCBieToKIC0gSW1wcm92aW5nIGxpZ2h0aW5nIGNvbmRpdGlvbnMK" + 
        "IC0gTW92aW5nIHRvIGFyZWEgd2l0aCBtb3JlIHZpc3VhbCBmZWF0dXJlcwogLSBSZWR1Y2luZyBtb3Rp" + 
        "b24gdG8gYWxsb3cgc3lzdGVtIHRvIHJlLWluaXRpYWxpemUKIC0gUGVyZm9ybWluZyBwb3NlIHJlc2V0" + 
        "IHdoZW4gdHJhY2tpbmcgcmVjb3ZlcnMKIAogRXh0ZXJuYWwgc3lzdGVtcyBzaG91bGQgbW9uaXRvciB0" + 
        "aGlzIGZpZWxkIGFuZCBpbXBsZW1lbnQgYXBwcm9wcmlhdGUKIGZhbGxiYWNrIGJlaGF2aW9ycyB3aGVu",
        "IHRyYWNraW5nIGlzIGxvc3QuCgoNCgUEAQIBBRIEogECBgoNCgUEAQIBARIEogEHGQoNCgUEAQIBAxIE" + 
        "ogEcHQraBQoEBAECAhIEuwECHBrLBSoKIFF1ZXN0IGRldmljZSBiYXR0ZXJ5IGxldmVsIGFzIGEgcGVy" + 
        "Y2VudGFnZSAoMC0xMDApLgogCiBUaGlzIHByb3ZpZGVzIHRoZSBjdXJyZW50IGJhdHRlcnkgY2hhcmdl" + 
        "IGxldmVsIG9mIHRoZSBRdWVzdCBoZWFkc2V0LAogYWxsb3dpbmcgZXh0ZXJuYWwgc3lzdGVtcyB0bzoK" + 
        "IC0gTW9uaXRvciBwb3dlciBzdGF0dXMgZHVyaW5nIG9wZXJhdGlvbgogLSBJbXBsZW1lbnQgbG93LWJh" + 
        "dHRlcnkgd2FybmluZ3Mgb3IgYmVoYXZpb3JzCiAtIFBsYW4gb3BlcmF0aW9uIGR1cmF0aW9uIGFuZCBj" + 
        "aGFyZ2luZyBuZWVkcwogLSBUcmlnZ2VyIGdyYWNlZnVsIHNodXRkb3duIHByb2NlZHVyZXMKIAogQmF0" + 
        "dGVyeSBMZXZlbCBHdWlkZWxpbmVzOgogLSAxMDAlOiBGdWxseSBjaGFyZ2VkCiAtIDUwLTEwMCU6IE5v" + 
        "cm1hbCBvcGVyYXRpb24KIC0gMjAtNTAlOiBDb25zaWRlciBjaGFyZ2luZyBzb29uCiAtIDEwLTIwJTog" + 
        "TG93IGJhdHRlcnkgd2FybmluZyByZWNvbW1lbmRlZAogLSAwLTEwJTogQ3JpdGljYWwgLSBwbGFuIGlt" + 
        "bWVkaWF0ZSBzaHV0ZG93bi9jaGFyZ2luZwogCiBOb3RlOiBCYXR0ZXJ5IGRyYWluIHJhdGUgZGVwZW5k" + 
        "cyBvbjoKIC0gUHJvY2Vzc2luZyBsb2FkICh0cmFja2luZyBjb21wbGV4aXR5KQogLSBEaXNwbGF5IHVz" + 
        "YWdlIChpZiBhbnkpCiAtIFdpcmVsZXNzIGNvbW11bmljYXRpb24gYWN0aXZpdHkKIC0gRW52aXJvbm1l" + 
        "bnRhbCB0ZW1wZXJhdHVyZQoKDQoFBAECAgUSBLsBAgcKDQoFBAECAgESBLsBCBcKDQoFBAECAgMSBLsB" + 
        "GhtiBnByb3RvMw==");

    static final Descriptors.FileDescriptor descriptor = Descriptors.FileDescriptor.internalBuildGeneratedFileFrom("data.proto", "questnav.protos.data", descriptorData, Geometry2D.getDescriptor());

    static final Descriptors.Descriptor questnav_protos_data_ProtobufQuestNavFrameData_descriptor = descriptor.internalContainedType(55, 141, "ProtobufQuestNavFrameData", "questnav.protos.data.ProtobufQuestNavFrameData");

    static final Descriptors.Descriptor questnav_protos_data_ProtobufQuestNavDeviceData_descriptor = descriptor.internalContainedType(199, 168, "ProtobufQuestNavDeviceData", "questnav.protos.data.ProtobufQuestNavDeviceData");

    /**
     * @return this proto file's descriptor.
     */
    public static Descriptors.FileDescriptor getDescriptor() {
        return descriptor;
    }

    /**
     * <pre>
     * *
     *  High-frequency tracking data sent from Quest to external systems.
     *  
     *  This message contains the core tracking information that external systems
     *  (like robot code) need for real-time localization and navigation. It's sent
     *  at high frequency (typically 30-90 Hz) to provide smooth, responsive tracking.
     *  
     *  The data represents the Quest's understanding of the robot's position and
     *  orientation on the field, derived from visual-inertial odometry using the
     *  Quest's cameras and IMU sensors.
     *  
     *  Coordinate System:
     *  - Uses WPILib field-relative coordinate system
     *  - Origin and axes depend on field setup and calibration
     *  - Pose represents the robot's position, not the Quest's position
     *    (accounting for Quest mounting offset)
     * </pre>
     *
     * Protobuf type {@code ProtobufQuestNavFrameData}
     */
    public static final class ProtobufQuestNavFrameData extends ProtoMessage<ProtobufQuestNavFrameData> implements Cloneable {
        private static final long serialVersionUID = 0L;

        /**
         * <pre>
         * *
         *  Timestamp in seconds since QuestNav app startup.
         *  
         *  This provides timing information for the tracking data, allowing external
         *  systems to:
         *  - Calculate data age and latency
         *  - Interpolate or extrapolate poses for prediction
         *  - Synchronize with other sensor data
         *  - Implement timeout detection
         *  
         *  The timestamp is relative to app startup, not system time, to avoid
         *  clock synchronization issues between devices.
         *  
         *  Resolution: Typically sub-millisecond precision
         * </pre>
         *
         * <code>optional double timestamp = 2;</code>
         */
        private double timestamp;

        /**
         * <pre>
         * *
         *  Sequential frame counter for this tracking session.
         *  
         *  This counter increments with each frame processed by the Quest's tracking
         *  system. It can be used to:
         *  - Detect dropped or out-of-order messages
         *  - Calculate effective frame rate
         *  - Synchronize with other data streams
         *  
         *  The counter resets to 0 when the QuestNav app starts and increments
         *  continuously during operation. Frame drops in transmission will create
         *  gaps in the sequence.
         * </pre>
         *
         * <code>optional int32 frame_count = 1;</code>
         */
        private int frameCount;

        /**
         * <pre>
         * *
         *  Robot's 2D pose on the field in WPILib coordinates.
         *  
         *  This represents the robot's position and orientation as determined by
         *  the Quest's tracking system. The pose accounts for:
         *  - Quest mounting position/orientation relative to robot center
         *  - Coordinate system transformation to WPILib standard
         *  - Any calibration offsets applied
         *  
         *  Coordinate System Details:
         *  - X: Forward direction (towards opposing alliance)
         *  - Y: Left direction (when facing forward)  
         *  - Rotation: Counter-clockwise positive (radians)
         *  - Units: meters for translation, radians for rotation
         *  
         *  Accuracy depends on:
         *  - Environmental lighting and features
         *  - Quest tracking quality
         *  - Calibration accuracy
         *  - Time since last pose reset
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose2d pose2d = 3;</code>
         */
        private final Geometry2D.ProtobufPose2d pose2D = Geometry2D.ProtobufPose2d.newInstance();

        private ProtobufQuestNavFrameData() {
        }

        /**
         * <pre>
         * *
         *  High-frequency tracking data sent from Quest to external systems.
         *  
         *  This message contains the core tracking information that external systems
         *  (like robot code) need for real-time localization and navigation. It's sent
         *  at high frequency (typically 30-90 Hz) to provide smooth, responsive tracking.
         *  
         *  The data represents the Quest's understanding of the robot's position and
         *  orientation on the field, derived from visual-inertial odometry using the
         *  Quest's cameras and IMU sensors.
         *  
         *  Coordinate System:
         *  - Uses WPILib field-relative coordinate system
         *  - Origin and axes depend on field setup and calibration
         *  - Pose represents the robot's position, not the Quest's position
         *    (accounting for Quest mounting offset)
         * </pre>
         *
         * @return a new empty instance of {@code ProtobufQuestNavFrameData}
         */
        public static ProtobufQuestNavFrameData newInstance() {
            return new ProtobufQuestNavFrameData();
        }

        /**
         * <pre>
         * *
         *  Timestamp in seconds since QuestNav app startup.
         *  
         *  This provides timing information for the tracking data, allowing external
         *  systems to:
         *  - Calculate data age and latency
         *  - Interpolate or extrapolate poses for prediction
         *  - Synchronize with other sensor data
         *  - Implement timeout detection
         *  
         *  The timestamp is relative to app startup, not system time, to avoid
         *  clock synchronization issues between devices.
         *  
         *  Resolution: Typically sub-millisecond precision
         * </pre>
         *
         * <code>optional double timestamp = 2;</code>
         * @return whether the timestamp field is set
         */
        public boolean hasTimestamp() {
            return (bitField0_ & 0x00000001) != 0;
        }

        /**
         * <pre>
         * *
         *  Timestamp in seconds since QuestNav app startup.
         *  
         *  This provides timing information for the tracking data, allowing external
         *  systems to:
         *  - Calculate data age and latency
         *  - Interpolate or extrapolate poses for prediction
         *  - Synchronize with other sensor data
         *  - Implement timeout detection
         *  
         *  The timestamp is relative to app startup, not system time, to avoid
         *  clock synchronization issues between devices.
         *  
         *  Resolution: Typically sub-millisecond precision
         * </pre>
         *
         * <code>optional double timestamp = 2;</code>
         * @return this
         */
        public ProtobufQuestNavFrameData clearTimestamp() {
            bitField0_ &= ~0x00000001;
            timestamp = 0D;
            return this;
        }

        /**
         * <pre>
         * *
         *  Timestamp in seconds since QuestNav app startup.
         *  
         *  This provides timing information for the tracking data, allowing external
         *  systems to:
         *  - Calculate data age and latency
         *  - Interpolate or extrapolate poses for prediction
         *  - Synchronize with other sensor data
         *  - Implement timeout detection
         *  
         *  The timestamp is relative to app startup, not system time, to avoid
         *  clock synchronization issues between devices.
         *  
         *  Resolution: Typically sub-millisecond precision
         * </pre>
         *
         * <code>optional double timestamp = 2;</code>
         * @return the timestamp
         */
        public double getTimestamp() {
            return timestamp;
        }

        /**
         * <pre>
         * *
         *  Timestamp in seconds since QuestNav app startup.
         *  
         *  This provides timing information for the tracking data, allowing external
         *  systems to:
         *  - Calculate data age and latency
         *  - Interpolate or extrapolate poses for prediction
         *  - Synchronize with other sensor data
         *  - Implement timeout detection
         *  
         *  The timestamp is relative to app startup, not system time, to avoid
         *  clock synchronization issues between devices.
         *  
         *  Resolution: Typically sub-millisecond precision
         * </pre>
         *
         * <code>optional double timestamp = 2;</code>
         * @param value the timestamp to set
         * @return this
         */
        public ProtobufQuestNavFrameData setTimestamp(final double value) {
            bitField0_ |= 0x00000001;
            timestamp = value;
            return this;
        }

        /**
         * <pre>
         * *
         *  Sequential frame counter for this tracking session.
         *  
         *  This counter increments with each frame processed by the Quest's tracking
         *  system. It can be used to:
         *  - Detect dropped or out-of-order messages
         *  - Calculate effective frame rate
         *  - Synchronize with other data streams
         *  
         *  The counter resets to 0 when the QuestNav app starts and increments
         *  continuously during operation. Frame drops in transmission will create
         *  gaps in the sequence.
         * </pre>
         *
         * <code>optional int32 frame_count = 1;</code>
         * @return whether the frameCount field is set
         */
        public boolean hasFrameCount() {
            return (bitField0_ & 0x00000002) != 0;
        }

        /**
         * <pre>
         * *
         *  Sequential frame counter for this tracking session.
         *  
         *  This counter increments with each frame processed by the Quest's tracking
         *  system. It can be used to:
         *  - Detect dropped or out-of-order messages
         *  - Calculate effective frame rate
         *  - Synchronize with other data streams
         *  
         *  The counter resets to 0 when the QuestNav app starts and increments
         *  continuously during operation. Frame drops in transmission will create
         *  gaps in the sequence.
         * </pre>
         *
         * <code>optional int32 frame_count = 1;</code>
         * @return this
         */
        public ProtobufQuestNavFrameData clearFrameCount() {
            bitField0_ &= ~0x00000002;
            frameCount = 0;
            return this;
        }

        /**
         * <pre>
         * *
         *  Sequential frame counter for this tracking session.
         *  
         *  This counter increments with each frame processed by the Quest's tracking
         *  system. It can be used to:
         *  - Detect dropped or out-of-order messages
         *  - Calculate effective frame rate
         *  - Synchronize with other data streams
         *  
         *  The counter resets to 0 when the QuestNav app starts and increments
         *  continuously during operation. Frame drops in transmission will create
         *  gaps in the sequence.
         * </pre>
         *
         * <code>optional int32 frame_count = 1;</code>
         * @return the frameCount
         */
        public int getFrameCount() {
            return frameCount;
        }

        /**
         * <pre>
         * *
         *  Sequential frame counter for this tracking session.
         *  
         *  This counter increments with each frame processed by the Quest's tracking
         *  system. It can be used to:
         *  - Detect dropped or out-of-order messages
         *  - Calculate effective frame rate
         *  - Synchronize with other data streams
         *  
         *  The counter resets to 0 when the QuestNav app starts and increments
         *  continuously during operation. Frame drops in transmission will create
         *  gaps in the sequence.
         * </pre>
         *
         * <code>optional int32 frame_count = 1;</code>
         * @param value the frameCount to set
         * @return this
         */
        public ProtobufQuestNavFrameData setFrameCount(final int value) {
            bitField0_ |= 0x00000002;
            frameCount = value;
            return this;
        }

        /**
         * <pre>
         * *
         *  Robot's 2D pose on the field in WPILib coordinates.
         *  
         *  This represents the robot's position and orientation as determined by
         *  the Quest's tracking system. The pose accounts for:
         *  - Quest mounting position/orientation relative to robot center
         *  - Coordinate system transformation to WPILib standard
         *  - Any calibration offsets applied
         *  
         *  Coordinate System Details:
         *  - X: Forward direction (towards opposing alliance)
         *  - Y: Left direction (when facing forward)  
         *  - Rotation: Counter-clockwise positive (radians)
         *  - Units: meters for translation, radians for rotation
         *  
         *  Accuracy depends on:
         *  - Environmental lighting and features
         *  - Quest tracking quality
         *  - Calibration accuracy
         *  - Time since last pose reset
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose2d pose2d = 3;</code>
         * @return whether the pose2D field is set
         */
        public boolean hasPose2D() {
            return (bitField0_ & 0x00000004) != 0;
        }

        /**
         * <pre>
         * *
         *  Robot's 2D pose on the field in WPILib coordinates.
         *  
         *  This represents the robot's position and orientation as determined by
         *  the Quest's tracking system. The pose accounts for:
         *  - Quest mounting position/orientation relative to robot center
         *  - Coordinate system transformation to WPILib standard
         *  - Any calibration offsets applied
         *  
         *  Coordinate System Details:
         *  - X: Forward direction (towards opposing alliance)
         *  - Y: Left direction (when facing forward)  
         *  - Rotation: Counter-clockwise positive (radians)
         *  - Units: meters for translation, radians for rotation
         *  
         *  Accuracy depends on:
         *  - Environmental lighting and features
         *  - Quest tracking quality
         *  - Calibration accuracy
         *  - Time since last pose reset
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose2d pose2d = 3;</code>
         * @return this
         */
        public ProtobufQuestNavFrameData clearPose2D() {
            bitField0_ &= ~0x00000004;
            pose2D.clear();
            return this;
        }

        /**
         * <pre>
         * *
         *  Robot's 2D pose on the field in WPILib coordinates.
         *  
         *  This represents the robot's position and orientation as determined by
         *  the Quest's tracking system. The pose accounts for:
         *  - Quest mounting position/orientation relative to robot center
         *  - Coordinate system transformation to WPILib standard
         *  - Any calibration offsets applied
         *  
         *  Coordinate System Details:
         *  - X: Forward direction (towards opposing alliance)
         *  - Y: Left direction (when facing forward)  
         *  - Rotation: Counter-clockwise positive (radians)
         *  - Units: meters for translation, radians for rotation
         *  
         *  Accuracy depends on:
         *  - Environmental lighting and features
         *  - Quest tracking quality
         *  - Calibration accuracy
         *  - Time since last pose reset
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose2d pose2d = 3;</code>
         *
         * This method returns the internal storage object without modifying any has state.
         * The returned object should not be modified and be treated as read-only.
         *
         * Use {@link #getMutablePose2D()} if you want to modify it.
         *
         * @return internal storage object for reading
         */
        public Geometry2D.ProtobufPose2d getPose2D() {
            return pose2D;
        }

        /**
         * <pre>
         * *
         *  Robot's 2D pose on the field in WPILib coordinates.
         *  
         *  This represents the robot's position and orientation as determined by
         *  the Quest's tracking system. The pose accounts for:
         *  - Quest mounting position/orientation relative to robot center
         *  - Coordinate system transformation to WPILib standard
         *  - Any calibration offsets applied
         *  
         *  Coordinate System Details:
         *  - X: Forward direction (towards opposing alliance)
         *  - Y: Left direction (when facing forward)  
         *  - Rotation: Counter-clockwise positive (radians)
         *  - Units: meters for translation, radians for rotation
         *  
         *  Accuracy depends on:
         *  - Environmental lighting and features
         *  - Quest tracking quality
         *  - Calibration accuracy
         *  - Time since last pose reset
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose2d pose2d = 3;</code>
         *
         * This method returns the internal storage object and sets the corresponding
         * has state. The returned object will become part of this message and its
         * contents may be modified as long as the has state is not cleared.
         *
         * @return internal storage object for modifications
         */
        public Geometry2D.ProtobufPose2d getMutablePose2D() {
            bitField0_ |= 0x00000004;
            return pose2D;
        }

        /**
         * <pre>
         * *
         *  Robot's 2D pose on the field in WPILib coordinates.
         *  
         *  This represents the robot's position and orientation as determined by
         *  the Quest's tracking system. The pose accounts for:
         *  - Quest mounting position/orientation relative to robot center
         *  - Coordinate system transformation to WPILib standard
         *  - Any calibration offsets applied
         *  
         *  Coordinate System Details:
         *  - X: Forward direction (towards opposing alliance)
         *  - Y: Left direction (when facing forward)  
         *  - Rotation: Counter-clockwise positive (radians)
         *  - Units: meters for translation, radians for rotation
         *  
         *  Accuracy depends on:
         *  - Environmental lighting and features
         *  - Quest tracking quality
         *  - Calibration accuracy
         *  - Time since last pose reset
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose2d pose2d = 3;</code>
         * @param value the pose2D to set
         * @return this
         */
        public ProtobufQuestNavFrameData setPose2D(final Geometry2D.ProtobufPose2d value) {
            bitField0_ |= 0x00000004;
            pose2D.copyFrom(value);
            return this;
        }

        @Override
        public ProtobufQuestNavFrameData copyFrom(final ProtobufQuestNavFrameData other) {
            cachedSize = other.cachedSize;
            if ((bitField0_ | other.bitField0_) != 0) {
                bitField0_ = other.bitField0_;
                timestamp = other.timestamp;
                frameCount = other.frameCount;
                pose2D.copyFrom(other.pose2D);
            }
            return this;
        }

        @Override
        public ProtobufQuestNavFrameData mergeFrom(final ProtobufQuestNavFrameData other) {
            if (other.isEmpty()) {
                return this;
            }
            cachedSize = -1;
            if (other.hasTimestamp()) {
                setTimestamp(other.timestamp);
            }
            if (other.hasFrameCount()) {
                setFrameCount(other.frameCount);
            }
            if (other.hasPose2D()) {
                getMutablePose2D().mergeFrom(other.pose2D);
            }
            return this;
        }

        @Override
        public ProtobufQuestNavFrameData clear() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            timestamp = 0D;
            frameCount = 0;
            pose2D.clear();
            return this;
        }

        @Override
        public ProtobufQuestNavFrameData clearQuick() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            pose2D.clearQuick();
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (o == this) {
                return true;
            }
            if (!(o instanceof ProtobufQuestNavFrameData)) {
                return false;
            }
            ProtobufQuestNavFrameData other = (ProtobufQuestNavFrameData) o;
            return bitField0_ == other.bitField0_
                && (!hasTimestamp() || ProtoUtil.isEqual(timestamp, other.timestamp))
                && (!hasFrameCount() || frameCount == other.frameCount)
                && (!hasPose2D() || pose2D.equals(other.pose2D));
        }

        @Override
        public void writeTo(final ProtoSink output) throws IOException {
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeRawByte((byte) 17);
                output.writeDoubleNoTag(timestamp);
            }
            if ((bitField0_ & 0x00000002) != 0) {
                output.writeRawByte((byte) 8);
                output.writeInt32NoTag(frameCount);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                output.writeRawByte((byte) 26);
                output.writeMessageNoTag(pose2D);
            }
        }

        @Override
        protected int computeSerializedSize() {
            int size = 0;
            if ((bitField0_ & 0x00000001) != 0) {
                size += 9;
            }
            if ((bitField0_ & 0x00000002) != 0) {
                size += 1 + ProtoSink.computeInt32SizeNoTag(frameCount);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                size += 1 + ProtoSink.computeMessageSizeNoTag(pose2D);
            }
            return size;
        }

        @Override
        @SuppressWarnings("fallthrough")
        public ProtobufQuestNavFrameData mergeFrom(final ProtoSource input) throws IOException {
            // Enabled Fall-Through Optimization (QuickBuffers)
            int tag = input.readTag();
            while (true) {
                switch (tag) {
                    case 17: {
                        // timestamp
                        timestamp = input.readDouble();
                        bitField0_ |= 0x00000001;
                        tag = input.readTag();
                        if (tag != 8) {
                            break;
                        }
                    }
                    case 8: {
                        // frameCount
                        frameCount = input.readInt32();
                        bitField0_ |= 0x00000002;
                        tag = input.readTag();
                        if (tag != 26) {
                            break;
                        }
                    }
                    case 26: {
                        // pose2D
                        input.readMessage(pose2D);
                        bitField0_ |= 0x00000004;
                        tag = input.readTag();
                        if (tag != 0) {
                            break;
                        }
                    }
                    case 0: {
                        return this;
                    }
                    default: {
                        if (!input.skipField(tag)) {
                            return this;
                        }
                        tag = input.readTag();
                        break;
                    }
                }
            }
        }

        @Override
        public void writeTo(final JsonSink output) throws IOException {
            output.beginObject();
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeDouble(FieldNames.timestamp, timestamp);
            }
            if ((bitField0_ & 0x00000002) != 0) {
                output.writeInt32(FieldNames.frameCount, frameCount);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                output.writeMessage(FieldNames.pose2D, pose2D);
            }
            output.endObject();
        }

        @Override
        public ProtobufQuestNavFrameData mergeFrom(final JsonSource input) throws IOException {
            if (!input.beginObject()) {
                return this;
            }
            while (!input.isAtEnd()) {
                switch (input.readFieldHash()) {
                    case 55126294: {
                        if (input.isAtField(FieldNames.timestamp)) {
                            if (!input.trySkipNullValue()) {
                                timestamp = input.readDouble();
                                bitField0_ |= 0x00000001;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    case -296512606:
                    case 188405693: {
                        if (input.isAtField(FieldNames.frameCount)) {
                            if (!input.trySkipNullValue()) {
                                frameCount = input.readInt32();
                                bitField0_ |= 0x00000002;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    case -982466877: {
                        if (input.isAtField(FieldNames.pose2D)) {
                            if (!input.trySkipNullValue()) {
                                input.readMessage(pose2D);
                                bitField0_ |= 0x00000004;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    default: {
                        input.skipUnknownField();
                        break;
                    }
                }
            }
            input.endObject();
            return this;
        }

        @Override
        public ProtobufQuestNavFrameData clone() {
            return new ProtobufQuestNavFrameData().copyFrom(this);
        }

        @Override
        public boolean isEmpty() {
            return ((bitField0_) == 0);
        }

        public static ProtobufQuestNavFrameData parseFrom(final byte[] data) throws
                InvalidProtocolBufferException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavFrameData(), data).checkInitialized();
        }

        public static ProtobufQuestNavFrameData parseFrom(final ProtoSource input) throws
                IOException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavFrameData(), input).checkInitialized();
        }

        public static ProtobufQuestNavFrameData parseFrom(final JsonSource input) throws
                IOException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavFrameData(), input).checkInitialized();
        }

        /**
         * @return factory for creating ProtobufQuestNavFrameData messages
         */
        public static MessageFactory<ProtobufQuestNavFrameData> getFactory() {
            return ProtobufQuestNavFrameDataFactory.INSTANCE;
        }

        /**
         * @return this type's descriptor.
         */
        public static Descriptors.Descriptor getDescriptor() {
            return Data.questnav_protos_data_ProtobufQuestNavFrameData_descriptor;
        }

        private enum ProtobufQuestNavFrameDataFactory implements MessageFactory<ProtobufQuestNavFrameData> {
            INSTANCE;

            @Override
            public ProtobufQuestNavFrameData create() {
                return ProtobufQuestNavFrameData.newInstance();
            }
        }

        /**
         * Contains name constants used for serializing JSON
         */
        static class FieldNames {
            static final FieldName timestamp = FieldName.forField("timestamp");

            static final FieldName frameCount = FieldName.forField("frameCount", "frame_count");

            static final FieldName pose2D = FieldName.forField("pose2d");
        }
    }

    /**
     * <pre>
     * *
     *  Lower-frequency device status data sent from Quest to external systems.
     *  
     *  This message contains device health and status information that doesn't need
     *  to be sent as frequently as tracking data. It's typically sent at 1-10 Hz
     *  to provide monitoring and diagnostic information without consuming excessive
     *  bandwidth.
     *  
     *  This data helps external systems:
     *  - Monitor Quest device health
     *  - Detect tracking system issues
     *  - Implement failsafe behaviors
     *  - Provide user feedback about system status
     *  
     *  The information is useful for both autonomous operation and debugging/
     *  troubleshooting scenarios.
     * </pre>
     *
     * Protobuf type {@code ProtobufQuestNavDeviceData}
     */
    public static final class ProtobufQuestNavDeviceData extends ProtoMessage<ProtobufQuestNavDeviceData> implements Cloneable {
        private static final long serialVersionUID = 0L;

        /**
         * <pre>
         * *
         *  Count of tracking loss events since app startup.
         *  
         *  This counter increments each time the Quest's tracking system loses
         *  tracking after having established it. Tracking loss can occur due to:
         *  - Poor lighting conditions
         *  - Lack of visual features in environment
         *  - Rapid motion or acceleration
         *  - Occlusion of cameras
         *  - Hardware issues
         *  
         *  A high or rapidly increasing counter may indicate:
         *  - Environmental issues (lighting, features)
         *  - Quest mounting problems (vibration, obstruction)
         *  - Hardware degradation
         *  
         *  This metric helps assess tracking system reliability and can trigger
         *  alerts or fallback behaviors in robot code.
         * </pre>
         *
         * <code>optional int32 tracking_lost_counter = 1;</code>
         */
        private int trackingLostCounter;

        /**
         * <pre>
         * *
         *  Quest device battery level as a percentage (0-100).
         *  
         *  This provides the current battery charge level of the Quest headset,
         *  allowing external systems to:
         *  - Monitor power status during operation
         *  - Implement low-battery warnings or behaviors
         *  - Plan operation duration and charging needs
         *  - Trigger graceful shutdown procedures
         *  
         *  Battery Level Guidelines:
         *  - 100%: Fully charged
         *  - 50-100%: Normal operation
         *  - 20-50%: Consider charging soon
         *  - 10-20%: Low battery warning recommended
         *  - 0-10%: Critical - plan immediate shutdown/charging
         *  
         *  Note: Battery drain rate depends on:
         *  - Processing load (tracking complexity)
         *  - Display usage (if any)
         *  - Wireless communication activity
         *  - Environmental temperature
         * </pre>
         *
         * <code>optional int32 battery_percent = 3;</code>
         */
        private int batteryPercent;

        /**
         * <pre>
         * *
         *  Current tracking status of the Quest device.
         *  
         *  true:  Quest is actively tracking and pose data is reliable
         *  false: Quest has lost tracking and pose data should not be trusted
         *  
         *  When tracking is lost:
         *  - Pose data becomes stale and unreliable
         *  - Robot should switch to alternative localization methods
         *  - Movement should be limited or stopped for safety
         *  
         *  Tracking can be recovered by:
         *  - Improving lighting conditions
         *  - Moving to area with more visual features
         *  - Reducing motion to allow system to re-initialize
         *  - Performing pose reset when tracking recovers
         *  
         *  External systems should monitor this field and implement appropriate
         *  fallback behaviors when tracking is lost.
         * </pre>
         *
         * <code>optional bool currently_tracking = 2;</code>
         */
        private boolean currentlyTracking;

        private ProtobufQuestNavDeviceData() {
        }

        /**
         * <pre>
         * *
         *  Lower-frequency device status data sent from Quest to external systems.
         *  
         *  This message contains device health and status information that doesn't need
         *  to be sent as frequently as tracking data. It's typically sent at 1-10 Hz
         *  to provide monitoring and diagnostic information without consuming excessive
         *  bandwidth.
         *  
         *  This data helps external systems:
         *  - Monitor Quest device health
         *  - Detect tracking system issues
         *  - Implement failsafe behaviors
         *  - Provide user feedback about system status
         *  
         *  The information is useful for both autonomous operation and debugging/
         *  troubleshooting scenarios.
         * </pre>
         *
         * @return a new empty instance of {@code ProtobufQuestNavDeviceData}
         */
        public static ProtobufQuestNavDeviceData newInstance() {
            return new ProtobufQuestNavDeviceData();
        }

        /**
         * <pre>
         * *
         *  Count of tracking loss events since app startup.
         *  
         *  This counter increments each time the Quest's tracking system loses
         *  tracking after having established it. Tracking loss can occur due to:
         *  - Poor lighting conditions
         *  - Lack of visual features in environment
         *  - Rapid motion or acceleration
         *  - Occlusion of cameras
         *  - Hardware issues
         *  
         *  A high or rapidly increasing counter may indicate:
         *  - Environmental issues (lighting, features)
         *  - Quest mounting problems (vibration, obstruction)
         *  - Hardware degradation
         *  
         *  This metric helps assess tracking system reliability and can trigger
         *  alerts or fallback behaviors in robot code.
         * </pre>
         *
         * <code>optional int32 tracking_lost_counter = 1;</code>
         * @return whether the trackingLostCounter field is set
         */
        public boolean hasTrackingLostCounter() {
            return (bitField0_ & 0x00000001) != 0;
        }

        /**
         * <pre>
         * *
         *  Count of tracking loss events since app startup.
         *  
         *  This counter increments each time the Quest's tracking system loses
         *  tracking after having established it. Tracking loss can occur due to:
         *  - Poor lighting conditions
         *  - Lack of visual features in environment
         *  - Rapid motion or acceleration
         *  - Occlusion of cameras
         *  - Hardware issues
         *  
         *  A high or rapidly increasing counter may indicate:
         *  - Environmental issues (lighting, features)
         *  - Quest mounting problems (vibration, obstruction)
         *  - Hardware degradation
         *  
         *  This metric helps assess tracking system reliability and can trigger
         *  alerts or fallback behaviors in robot code.
         * </pre>
         *
         * <code>optional int32 tracking_lost_counter = 1;</code>
         * @return this
         */
        public ProtobufQuestNavDeviceData clearTrackingLostCounter() {
            bitField0_ &= ~0x00000001;
            trackingLostCounter = 0;
            return this;
        }

        /**
         * <pre>
         * *
         *  Count of tracking loss events since app startup.
         *  
         *  This counter increments each time the Quest's tracking system loses
         *  tracking after having established it. Tracking loss can occur due to:
         *  - Poor lighting conditions
         *  - Lack of visual features in environment
         *  - Rapid motion or acceleration
         *  - Occlusion of cameras
         *  - Hardware issues
         *  
         *  A high or rapidly increasing counter may indicate:
         *  - Environmental issues (lighting, features)
         *  - Quest mounting problems (vibration, obstruction)
         *  - Hardware degradation
         *  
         *  This metric helps assess tracking system reliability and can trigger
         *  alerts or fallback behaviors in robot code.
         * </pre>
         *
         * <code>optional int32 tracking_lost_counter = 1;</code>
         * @return the trackingLostCounter
         */
        public int getTrackingLostCounter() {
            return trackingLostCounter;
        }

        /**
         * <pre>
         * *
         *  Count of tracking loss events since app startup.
         *  
         *  This counter increments each time the Quest's tracking system loses
         *  tracking after having established it. Tracking loss can occur due to:
         *  - Poor lighting conditions
         *  - Lack of visual features in environment
         *  - Rapid motion or acceleration
         *  - Occlusion of cameras
         *  - Hardware issues
         *  
         *  A high or rapidly increasing counter may indicate:
         *  - Environmental issues (lighting, features)
         *  - Quest mounting problems (vibration, obstruction)
         *  - Hardware degradation
         *  
         *  This metric helps assess tracking system reliability and can trigger
         *  alerts or fallback behaviors in robot code.
         * </pre>
         *
         * <code>optional int32 tracking_lost_counter = 1;</code>
         * @param value the trackingLostCounter to set
         * @return this
         */
        public ProtobufQuestNavDeviceData setTrackingLostCounter(final int value) {
            bitField0_ |= 0x00000001;
            trackingLostCounter = value;
            return this;
        }

        /**
         * <pre>
         * *
         *  Quest device battery level as a percentage (0-100).
         *  
         *  This provides the current battery charge level of the Quest headset,
         *  allowing external systems to:
         *  - Monitor power status during operation
         *  - Implement low-battery warnings or behaviors
         *  - Plan operation duration and charging needs
         *  - Trigger graceful shutdown procedures
         *  
         *  Battery Level Guidelines:
         *  - 100%: Fully charged
         *  - 50-100%: Normal operation
         *  - 20-50%: Consider charging soon
         *  - 10-20%: Low battery warning recommended
         *  - 0-10%: Critical - plan immediate shutdown/charging
         *  
         *  Note: Battery drain rate depends on:
         *  - Processing load (tracking complexity)
         *  - Display usage (if any)
         *  - Wireless communication activity
         *  - Environmental temperature
         * </pre>
         *
         * <code>optional int32 battery_percent = 3;</code>
         * @return whether the batteryPercent field is set
         */
        public boolean hasBatteryPercent() {
            return (bitField0_ & 0x00000002) != 0;
        }

        /**
         * <pre>
         * *
         *  Quest device battery level as a percentage (0-100).
         *  
         *  This provides the current battery charge level of the Quest headset,
         *  allowing external systems to:
         *  - Monitor power status during operation
         *  - Implement low-battery warnings or behaviors
         *  - Plan operation duration and charging needs
         *  - Trigger graceful shutdown procedures
         *  
         *  Battery Level Guidelines:
         *  - 100%: Fully charged
         *  - 50-100%: Normal operation
         *  - 20-50%: Consider charging soon
         *  - 10-20%: Low battery warning recommended
         *  - 0-10%: Critical - plan immediate shutdown/charging
         *  
         *  Note: Battery drain rate depends on:
         *  - Processing load (tracking complexity)
         *  - Display usage (if any)
         *  - Wireless communication activity
         *  - Environmental temperature
         * </pre>
         *
         * <code>optional int32 battery_percent = 3;</code>
         * @return this
         */
        public ProtobufQuestNavDeviceData clearBatteryPercent() {
            bitField0_ &= ~0x00000002;
            batteryPercent = 0;
            return this;
        }

        /**
         * <pre>
         * *
         *  Quest device battery level as a percentage (0-100).
         *  
         *  This provides the current battery charge level of the Quest headset,
         *  allowing external systems to:
         *  - Monitor power status during operation
         *  - Implement low-battery warnings or behaviors
         *  - Plan operation duration and charging needs
         *  - Trigger graceful shutdown procedures
         *  
         *  Battery Level Guidelines:
         *  - 100%: Fully charged
         *  - 50-100%: Normal operation
         *  - 20-50%: Consider charging soon
         *  - 10-20%: Low battery warning recommended
         *  - 0-10%: Critical - plan immediate shutdown/charging
         *  
         *  Note: Battery drain rate depends on:
         *  - Processing load (tracking complexity)
         *  - Display usage (if any)
         *  - Wireless communication activity
         *  - Environmental temperature
         * </pre>
         *
         * <code>optional int32 battery_percent = 3;</code>
         * @return the batteryPercent
         */
        public int getBatteryPercent() {
            return batteryPercent;
        }

        /**
         * <pre>
         * *
         *  Quest device battery level as a percentage (0-100).
         *  
         *  This provides the current battery charge level of the Quest headset,
         *  allowing external systems to:
         *  - Monitor power status during operation
         *  - Implement low-battery warnings or behaviors
         *  - Plan operation duration and charging needs
         *  - Trigger graceful shutdown procedures
         *  
         *  Battery Level Guidelines:
         *  - 100%: Fully charged
         *  - 50-100%: Normal operation
         *  - 20-50%: Consider charging soon
         *  - 10-20%: Low battery warning recommended
         *  - 0-10%: Critical - plan immediate shutdown/charging
         *  
         *  Note: Battery drain rate depends on:
         *  - Processing load (tracking complexity)
         *  - Display usage (if any)
         *  - Wireless communication activity
         *  - Environmental temperature
         * </pre>
         *
         * <code>optional int32 battery_percent = 3;</code>
         * @param value the batteryPercent to set
         * @return this
         */
        public ProtobufQuestNavDeviceData setBatteryPercent(final int value) {
            bitField0_ |= 0x00000002;
            batteryPercent = value;
            return this;
        }

        /**
         * <pre>
         * *
         *  Current tracking status of the Quest device.
         *  
         *  true:  Quest is actively tracking and pose data is reliable
         *  false: Quest has lost tracking and pose data should not be trusted
         *  
         *  When tracking is lost:
         *  - Pose data becomes stale and unreliable
         *  - Robot should switch to alternative localization methods
         *  - Movement should be limited or stopped for safety
         *  
         *  Tracking can be recovered by:
         *  - Improving lighting conditions
         *  - Moving to area with more visual features
         *  - Reducing motion to allow system to re-initialize
         *  - Performing pose reset when tracking recovers
         *  
         *  External systems should monitor this field and implement appropriate
         *  fallback behaviors when tracking is lost.
         * </pre>
         *
         * <code>optional bool currently_tracking = 2;</code>
         * @return whether the currentlyTracking field is set
         */
        public boolean hasCurrentlyTracking() {
            return (bitField0_ & 0x00000004) != 0;
        }

        /**
         * <pre>
         * *
         *  Current tracking status of the Quest device.
         *  
         *  true:  Quest is actively tracking and pose data is reliable
         *  false: Quest has lost tracking and pose data should not be trusted
         *  
         *  When tracking is lost:
         *  - Pose data becomes stale and unreliable
         *  - Robot should switch to alternative localization methods
         *  - Movement should be limited or stopped for safety
         *  
         *  Tracking can be recovered by:
         *  - Improving lighting conditions
         *  - Moving to area with more visual features
         *  - Reducing motion to allow system to re-initialize
         *  - Performing pose reset when tracking recovers
         *  
         *  External systems should monitor this field and implement appropriate
         *  fallback behaviors when tracking is lost.
         * </pre>
         *
         * <code>optional bool currently_tracking = 2;</code>
         * @return this
         */
        public ProtobufQuestNavDeviceData clearCurrentlyTracking() {
            bitField0_ &= ~0x00000004;
            currentlyTracking = false;
            return this;
        }

        /**
         * <pre>
         * *
         *  Current tracking status of the Quest device.
         *  
         *  true:  Quest is actively tracking and pose data is reliable
         *  false: Quest has lost tracking and pose data should not be trusted
         *  
         *  When tracking is lost:
         *  - Pose data becomes stale and unreliable
         *  - Robot should switch to alternative localization methods
         *  - Movement should be limited or stopped for safety
         *  
         *  Tracking can be recovered by:
         *  - Improving lighting conditions
         *  - Moving to area with more visual features
         *  - Reducing motion to allow system to re-initialize
         *  - Performing pose reset when tracking recovers
         *  
         *  External systems should monitor this field and implement appropriate
         *  fallback behaviors when tracking is lost.
         * </pre>
         *
         * <code>optional bool currently_tracking = 2;</code>
         * @return the currentlyTracking
         */
        public boolean getCurrentlyTracking() {
            return currentlyTracking;
        }

        /**
         * <pre>
         * *
         *  Current tracking status of the Quest device.
         *  
         *  true:  Quest is actively tracking and pose data is reliable
         *  false: Quest has lost tracking and pose data should not be trusted
         *  
         *  When tracking is lost:
         *  - Pose data becomes stale and unreliable
         *  - Robot should switch to alternative localization methods
         *  - Movement should be limited or stopped for safety
         *  
         *  Tracking can be recovered by:
         *  - Improving lighting conditions
         *  - Moving to area with more visual features
         *  - Reducing motion to allow system to re-initialize
         *  - Performing pose reset when tracking recovers
         *  
         *  External systems should monitor this field and implement appropriate
         *  fallback behaviors when tracking is lost.
         * </pre>
         *
         * <code>optional bool currently_tracking = 2;</code>
         * @param value the currentlyTracking to set
         * @return this
         */
        public ProtobufQuestNavDeviceData setCurrentlyTracking(final boolean value) {
            bitField0_ |= 0x00000004;
            currentlyTracking = value;
            return this;
        }

        @Override
        public ProtobufQuestNavDeviceData copyFrom(final ProtobufQuestNavDeviceData other) {
            cachedSize = other.cachedSize;
            if ((bitField0_ | other.bitField0_) != 0) {
                bitField0_ = other.bitField0_;
                trackingLostCounter = other.trackingLostCounter;
                batteryPercent = other.batteryPercent;
                currentlyTracking = other.currentlyTracking;
            }
            return this;
        }

        @Override
        public ProtobufQuestNavDeviceData mergeFrom(final ProtobufQuestNavDeviceData other) {
            if (other.isEmpty()) {
                return this;
            }
            cachedSize = -1;
            if (other.hasTrackingLostCounter()) {
                setTrackingLostCounter(other.trackingLostCounter);
            }
            if (other.hasBatteryPercent()) {
                setBatteryPercent(other.batteryPercent);
            }
            if (other.hasCurrentlyTracking()) {
                setCurrentlyTracking(other.currentlyTracking);
            }
            return this;
        }

        @Override
        public ProtobufQuestNavDeviceData clear() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            trackingLostCounter = 0;
            batteryPercent = 0;
            currentlyTracking = false;
            return this;
        }

        @Override
        public ProtobufQuestNavDeviceData clearQuick() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (o == this) {
                return true;
            }
            if (!(o instanceof ProtobufQuestNavDeviceData)) {
                return false;
            }
            ProtobufQuestNavDeviceData other = (ProtobufQuestNavDeviceData) o;
            return bitField0_ == other.bitField0_
                && (!hasTrackingLostCounter() || trackingLostCounter == other.trackingLostCounter)
                && (!hasBatteryPercent() || batteryPercent == other.batteryPercent)
                && (!hasCurrentlyTracking() || currentlyTracking == other.currentlyTracking);
        }

        @Override
        public void writeTo(final ProtoSink output) throws IOException {
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeRawByte((byte) 8);
                output.writeInt32NoTag(trackingLostCounter);
            }
            if ((bitField0_ & 0x00000002) != 0) {
                output.writeRawByte((byte) 24);
                output.writeInt32NoTag(batteryPercent);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                output.writeRawByte((byte) 16);
                output.writeBoolNoTag(currentlyTracking);
            }
        }

        @Override
        protected int computeSerializedSize() {
            int size = 0;
            if ((bitField0_ & 0x00000001) != 0) {
                size += 1 + ProtoSink.computeInt32SizeNoTag(trackingLostCounter);
            }
            if ((bitField0_ & 0x00000002) != 0) {
                size += 1 + ProtoSink.computeInt32SizeNoTag(batteryPercent);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                size += 2;
            }
            return size;
        }

        @Override
        @SuppressWarnings("fallthrough")
        public ProtobufQuestNavDeviceData mergeFrom(final ProtoSource input) throws IOException {
            // Enabled Fall-Through Optimization (QuickBuffers)
            int tag = input.readTag();
            while (true) {
                switch (tag) {
                    case 8: {
                        // trackingLostCounter
                        trackingLostCounter = input.readInt32();
                        bitField0_ |= 0x00000001;
                        tag = input.readTag();
                        if (tag != 24) {
                            break;
                        }
                    }
                    case 24: {
                        // batteryPercent
                        batteryPercent = input.readInt32();
                        bitField0_ |= 0x00000002;
                        tag = input.readTag();
                        if (tag != 16) {
                            break;
                        }
                    }
                    case 16: {
                        // currentlyTracking
                        currentlyTracking = input.readBool();
                        bitField0_ |= 0x00000004;
                        tag = input.readTag();
                        if (tag != 0) {
                            break;
                        }
                    }
                    case 0: {
                        return this;
                    }
                    default: {
                        if (!input.skipField(tag)) {
                            return this;
                        }
                        tag = input.readTag();
                        break;
                    }
                }
            }
        }

        @Override
        public void writeTo(final JsonSink output) throws IOException {
            output.beginObject();
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeInt32(FieldNames.trackingLostCounter, trackingLostCounter);
            }
            if ((bitField0_ & 0x00000002) != 0) {
                output.writeInt32(FieldNames.batteryPercent, batteryPercent);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                output.writeBool(FieldNames.currentlyTracking, currentlyTracking);
            }
            output.endObject();
        }

        @Override
        public ProtobufQuestNavDeviceData mergeFrom(final JsonSource input) throws IOException {
            if (!input.beginObject()) {
                return this;
            }
            while (!input.isAtEnd()) {
                switch (input.readFieldHash()) {
                    case -1237870847:
                    case -2011984791: {
                        if (input.isAtField(FieldNames.trackingLostCounter)) {
                            if (!input.trySkipNullValue()) {
                                trackingLostCounter = input.readInt32();
                                bitField0_ |= 0x00000001;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    case -2041653896:
                    case -1975165933: {
                        if (input.isAtField(FieldNames.batteryPercent)) {
                            if (!input.trySkipNullValue()) {
                                batteryPercent = input.readInt32();
                                bitField0_ |= 0x00000002;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    case 879013277:
                    case 106200592: {
                        if (input.isAtField(FieldNames.currentlyTracking)) {
                            if (!input.trySkipNullValue()) {
                                currentlyTracking = input.readBool();
                                bitField0_ |= 0x00000004;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    default: {
                        input.skipUnknownField();
                        break;
                    }
                }
            }
            input.endObject();
            return this;
        }

        @Override
        public ProtobufQuestNavDeviceData clone() {
            return new ProtobufQuestNavDeviceData().copyFrom(this);
        }

        @Override
        public boolean isEmpty() {
            return ((bitField0_) == 0);
        }

        public static ProtobufQuestNavDeviceData parseFrom(final byte[] data) throws
                InvalidProtocolBufferException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavDeviceData(), data).checkInitialized();
        }

        public static ProtobufQuestNavDeviceData parseFrom(final ProtoSource input) throws
                IOException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavDeviceData(), input).checkInitialized();
        }

        public static ProtobufQuestNavDeviceData parseFrom(final JsonSource input) throws
                IOException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavDeviceData(), input).checkInitialized();
        }

        /**
         * @return factory for creating ProtobufQuestNavDeviceData messages
         */
        public static MessageFactory<ProtobufQuestNavDeviceData> getFactory() {
            return ProtobufQuestNavDeviceDataFactory.INSTANCE;
        }

        /**
         * @return this type's descriptor.
         */
        public static Descriptors.Descriptor getDescriptor() {
            return Data.questnav_protos_data_ProtobufQuestNavDeviceData_descriptor;
        }

        private enum ProtobufQuestNavDeviceDataFactory implements MessageFactory<ProtobufQuestNavDeviceData> {
            INSTANCE;

            @Override
            public ProtobufQuestNavDeviceData create() {
                return ProtobufQuestNavDeviceData.newInstance();
            }
        }

        /**
         * Contains name constants used for serializing JSON
         */
        static class FieldNames {
            static final FieldName trackingLostCounter = FieldName.forField("trackingLostCounter", "tracking_lost_counter");

            static final FieldName batteryPercent = FieldName.forField("batteryPercent", "battery_percent");

            static final FieldName currentlyTracking = FieldName.forField("currentlyTracking", "currently_tracking");
        }
    }
}
